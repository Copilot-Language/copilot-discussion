\section{Copilot}~\label{sec:co-intro} 


\paragraph{Copilot's expression language.}
In the following, we briefly and informally introduce Copilot's expression
language. Copilot is a \emph{steam} based language with many similarities to Lustre~\cite{CaspiPHP87}.
 The Copilot language mimics both the syntax and semantics of lazy lists (which we
call \emph{streams}) in Haskell.  One notable exception though is that
operators are automatically promoted point-wise to the list level..  For
example, the Fibonacci sequence modulo $2^{32}$ can be written in Copilot as follows:

\begin{lstlisting}[frame=single]
fib :: Stream Word32
fib = [0,1] ++ (fib + drop 1 fib)
\end{lstlisting}
%
Recall, a 
latch (flip-flop) over streams---the output is the XOR of the input stream and
the latch's previous output.  For example, for the input stream
$\mathtt{T, F, F, T, F, F, T, F, F,}\dots$
{\tt latch} generates the stream
$\mathtt{F, T, T, T, F, F, F, T, T, T,}\ldots$
The Copliot implementaton of {\tt latch} is as follows:
%
\begin{lstlisting}[frame=single]
latch :: Stream Bool -> Stream Bool
latch x = out
  where out = [False] ++ x `xor` out
\end{lstlisting}
%
The base types of Copilot over which streams are built include Booleans, signed
and unsigned words of 8, 16, 32, and 64 bits, floats, and doubles. Type-safe
casts in which overflow cannot occur are permitted.

\paragraph{Sampling.}
Copilot programs are meant to monitor arbitrary C~programs.  They do
so by
periodically \emph{sampling} symbol values. (Copilot samples variables, arrays,
and the return values of side-effect free functions---sampling arbitrary
structures is future work.)  For a Copilot program compiled to~C, symbols become
in-scope when arbitrary C~code is linked with the code generated by the Copilot
compiler.  Copilot provides the operator {\tt extern} to introduce an external
symbol to sample.  The operator types a string denoting the C~symbol.



%Copilot can be interpreted as well as compiled.  When interpreted,
%representative values are expected to be supplied by the programmer.  For
%example, the following stream samples the C variable {\tt e0} of type {\tt
%  uint8\_t} to create each new stream index.  If {\tt e0} takes the values {\tt
% 2, 4, 6, 8,...}  the stream {\tt ext} has the values {\tt 1, 3, 7, 13,...}.
%
%\begin{lstlisting}[frame=single]
%ext :: Stream Word8
%ext = [1] ++ (ext + extern "e0" interp)
%  where interp = Just [2,4..]
%\end{lstlisting}
%
%We make the design decision to build interpreter values for external values
%into the language.  (If the user wishes not to provide interpreter values,
%the constructor {\tt Nothing} can be used.)

Sampling arrays and functions is similar (for space constraints, we omit an
example of function sampling).  For example, the following stream samples an
array with the prototype {\tt uint32\_t arr[3]}:
%
\begin{lstlisting}[frame=single]
arr :: Stream Word32
arr = externArray "arr" idx 3 interp
  where idx :: Stream Word8
        idx    = [0] ++ (idx + 1) `mod` 2
        interp = Just (repeat [0,1,2])
\end{lstlisting}
% $
%The interpreter takes a list of lists to represent possible array values.

%Finally, the following stream samples the return value of an external function
%with the prototype {\tt int16\_t f(double x, bool y)} by calling the function
%with appropriately-typed arguments:
%
%\begin{lstlisting}[frame=single]
%func :: Stream Word16
%func = [3] ++ externFun "f" [ arg x, arg y ] interp
%  where x :: Stream Double
%        x = 3.2
%        y :: Stream Double
%        y = [5.0] ++ y * 2
%        interp = Just (x + y)
%\end{lstlisting}
%
%Note that for functions, the interpreter takes a Copilot program over the input
%streams to the function.


%\paragraph{Effects.}
%Copilot has exactly one mechanism for output called \emph{triggers}.  For
%example, consider the following example trigger:
%
%\begin{lstlisting}[frame=single]
%trigger "trig" (fib `mod` 2 == 0)
%  [ arg fib, arg (latch fib) ]
%\end{lstlisting}%
%A trigger has a guard that is a Boolean-valued Copilot stream, and a list of
%arguments, which are Copilot expressions.  A trigger is \emph{fired} exactly
%when its guard (stating that the current value from the {\tt fib} stream is
%even in this case) is true.  A trigger's implementation is a C~function with a
%{\tt void} return type that takes the current values of the trigger arguments as
%arguments.  For example, given the definition of {\tt fib} and {\tt latch}
%above, the prototype of the C-function implementing the trigger {\tt trig}
%defined above is
%
%\begin{lstlisting}[frame=single]
%void trig(uint32_t, bool);
%\end{lstlisting}
%
%The definition of a trigger is implementation-dependent and up to
%the programmer to implement.

