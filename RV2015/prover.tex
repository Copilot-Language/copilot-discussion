\section{Copilot Prover Interface}~\label{sec:prover} 
We have modified  the Copilot framework with an extensible interface  to multiple
provers, called \texttt{copilot-kind}, aimed at checking  safety properties on Copilot
programs. Currently Copilot interacts with two provers: the first is a
homegrown prover we call ``the light prover'' built on top of
Yices~\cite{Dutertre:cav2014} and the second is the Kind2 model checker~\cite{kind2} being developed at
the University of Iowa.

Let us illustrate the use of the verification functionality with a
very simple example.  Safety properties are simply expressed with
standard boolean streams.  We bind a boolean stream to a property name
with the \texttt{prop} construct in the specification, where the
specification has type \texttt{Spec}.

For instance, here is a straightforward specification declaring one
property :

\begin{lstlisting}[frame=single]
spec :: Spec
spec = do
  prop "gt0" (x > 0)
  where
    x = [1] ++ (1 + x)
\end{lstlisting}

Let's say we want to check that \texttt{gt0} holds. For this, we use
the function

\begin{lstlisting}[frame=single]
    prove :: Prover -> ProofScheme -> Spec -> IO ()
\end{lstlisting}

Here, we can discharge the proof by  using the light prover using the command:
\begin{code}
prove (lightProver def) (check "gt0") spec
\end{code}
where \texttt{lightProver def} stands for the \emph{light prover} with
default configuration.  

\subsubsection{The Prover Interface.}\label{the-prover-interface}

The \texttt{Copilot-Kind} provides a general interface for
provers. Therefore, it is really easy to add a new prover by creating a
new object of type \texttt{Prover}. The latter is defined as follows:

\begin{lstlisting}[frame=single]
data Output = Output Status Infos
type Infos = [String]
data Status
  = Valid
  | Invalid (Maybe Cex)   -- 'Cex' is the type for counterexamples
  | Unknown
  | Error
  
data Prover = forall r. Prover 
  { proverName     :: String
  , hasFeature     :: Feature -> Bool
  , startProver    :: Core.Spec -> IO r
  , closeProver    :: r -> IO () 
  , askProver      :: r          -- ^ The prover internal state
                   -> [PropId]   -- ^ A list of assumptions A
                   -> PropId     -- ^ The property to prove P
                   -> IO Output  -- ^ Whether or not A entails P
  }

\end{lstlisting}

To interface with a particular prover, one must mostly provide an \texttt{askProver} function that
takes as its arguments the internal state of the prover, a list of assumptions $(A_i)_i$ and a property $P$ and decides whether or not : \[ \bigwedge_i A_i \models P  \] In the case the answer is \emph{no}, a counterexample trace leading to a state where $\bigwedge_i A_i \,\wedge\, \neg P$ is true is given. Moreover, even if the prover was given no time limit, we might still get the answer \emph{unknown} as the request might not be expressible in a decidable subset of a \textsc{smt-lib} theory\footnote{For instance, even Peano arithmetic is undecidable in general.}.
%\begin{itemize}
%\item \texttt{Valid} if the entailment holds.
%\item \texttt{Invalid} if it does not, in which case.
%\item \texttt{Unknown} if the prover can't find out. This type of answer is necessary even if the %prover has no time limit, as 
%\item \texttt{Error} when something wrong happens.
%\end{itemize}
Two provers are currently supported by default :
\begin{itemize}
\item The homegrown \emph{light prover} which uses the Yices \textsc{smt}-solver with the \textsc{qf\_uflia} theory and which implements the basic $k$-induction algorithm.
\item A prover based on the \emph{Kind2} model checker, which implements both $k$-induction and the more subtle IC3 algorithm.
\end{itemize}


%It is provided by the \texttt{Copilot.Kind.Kind2} module, which exports
%a $$\texttt{kind2Prover :: Options -\textgreater{} Prover}$$ where the
%\texttt{Options} type is defined as
%
%\begin{lstlisting}[frame=single]
%data Options = Options { bmcMax :: Int }
%\end{lstlisting}

%and where \texttt{bmcMax} corresponds to the \texttt{-\/-bmc\_max}
%option of \emph{kind2} and is equivalent to the \texttt{kTimeout} option
%of the light prover. Its default value is $0,$ which stands for infinity.

\subsubsection{Combining Provers.}\label{combining-provers}
Different provers can be combined into a single one. We provide a \texttt{combine} function whose signature is : $$\texttt{combine :: Prover -\textgreater{} Prover -\textgreater{} Prover}$$ that merge two provers $A$ and $B$ into a prover $C$ which
launches both $A$ and $B$ and returns the most \emph{precise}\footnote{For instance, \texttt{Valid} is more {precise} than \texttt{Unknown} and one of two \texttt{Invalid} outputs might fail to hold a counterexample, in case the other is more precise.} output after they both stop. Smarter merging behaviors could be implemented, as running two provers in parallel and waiting the first one to stop.

In practice, we used the following prover in the examples of Section~\ref{sec:example} :
\begin{lstlisting}[frame=single]
prover = lightProver def {kTimeout = 5} `combine` kind2Prover def
\end{lstlisting}
which uses both the light and Kind2 provers, the first being limited to 5 steps of the $k$-induction 

\subsubsection{Proof Schemes.}\label{proof-schemes}

Let's consider again this example :

\begin{lstlisting}[frame=single]
spec :: Spec
spec = do
  prop "gt0"  (x > 0)
  prop "neq0" (x /= 0)
  where
    x = [1] ++ (1 + x)

\end{lstlisting}
and let us say we want to prove \texttt{"neq0"}. Currently, the two available solvers fail at showing this non-inductive\footnote{Non-inductive : whose induction step does not hold. See Section~\ref{sec:background}.} property. Yet, we can prove the more general
inductive lemma \texttt{"gt0"} and deduce our main goal from this. For
this, we use the proof scheme

\begin{lstlisting}[frame=single]
assert "gt0" >> check "neq0"
\end{lstlisting}


instead of just 
\begin{lstlisting}[frame=single] 
  check "neq0" 
\end{lstlisting}
A proof scheme is a chain of
primitives schemes glued by the $\texttt{\textgreater{}\textgreater{}}$
operator. For now, the available primitives are :

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{check "prop"} checks whether or not a given property is true
  in the current context.
\item
  \texttt{assume "prop"} adds an assumption in the current context.
\item
  \texttt{assert "prop"} is a shortcut for
  \texttt{check "prop" \textgreater{}\textgreater{} assume "prop"}.
\item

\texttt{assuming props scheme} assumes the list of
  properties \emph{props}, executes the proof scheme \emph{scheme} in
  this context, and forgets the assumptions. The signature of \texttt{assuming} is  
 {\texttt{{[}PropId{]} -\textgreater{} ProofScheme -\textgreater{} ProofScheme}}.

\item
  \texttt{msg "..."} displays a string in the standard output.
\end{itemize}

Although very simple, such a mechanism is necessary to make our model-checking approach scale up by splitting a proof in small lemmas. Some possible enhancements of it will be discussed in Section~\ref{sec:conclusion}.
