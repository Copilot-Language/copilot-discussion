\section{Introduction}\label{sec:intro}
Runtime Verification (RV), where monitors detect and respond to
property violations at runtime, can help address several of the
verification challenges facing ultra-critical
systems~\cite{pike-rv-11}.  As RV matures it will be employed to
verify increasingly complex properties. For instance, checking complex
stability properties of a control system or ensuring that a critical
system is fault-tolerant. As interest grows in techniques
such as adaptive flight control and fully autonomous vehicles that
utilize learning to adapt to unpredictable environments, RV may be a
way to regain the necessary level of predictability required of
ultra-critical systems.  As RV is applied to more complex systems the
monitors themselves will become increasing sophisticated and just as
with the software itself prone to error.  Applying formal verification
tools to the monitors to ensure they are correct can help safeguard
that the last line of defense is actually effective.

 The work reported on here is part of a larger
program aimed at creating a framework for \emph{high assurance RV}. In
order to be used in ultra-critical environments, high-assurance RV
must: 
\begin{itemize}
\item Support the production of evidence needed for a safety case
  employing RV enforce safety guarantees.
\item Support the verification that the specification of the monitors
  is indeed correct. 
\item Ensure that monitor code generated implements the specification of the
monitor. 
\end{itemize} 
 These guiding principles are informing the continuing development of the Copilot~\cite{copilot,pike-isse-13} language and framework that is
intended to be used in RV of ultra-critical systems.  Earlier
work~\cite{pike-icfp-12} focused verifying that the monitor synthesis
process was correct. Here, the focus is on the second requirement for
high-assurance RV - making sure the monitor  correct. 

                                     
%This paper documents our efforts in incorporating formal verification
%of monitors into the Copilot RV framework.  Initial efforts have
%focused on verifying invariants using advanced Satisfiability Modulo
%Theories (SMT) based bounded model
%checking~\cite{ClarkeBounded01}.  




%The next section provides the reader with the necessary background on
%Copilot. Section~\ref{sec:background} gives a brief introduction to
%the $k-$induction proof technique we apply to verify
%monitors.
%\jonathan{To be exact, we don't limit ourselves to k-induction as Kind2 relies heavily on the IC3 algorithm. Maybe we should use the term "SMT-based model-checking" instead. That being said, as I'll try to explain, it's true IC3 didn't work significantly better than basic k-induction in all the test cases I ran.}
%Section~\ref{sec:prover} introduces the new Copilot prover
%interface. In Section~\ref{sec:example}, several examples illustrate
%the application of the tool to the Boyer-Moore majority vote
%algorithm. Section~\ref{sec:structure} provides an overview of
%implementation details. Section~\ref{sec:related} discusses related
%works. Finally, Section~\ref{sec:conclusion}
%discusses future work and concludes.



%Copilot is a stream
%  language for generating embedded C-code monitors for verifying
%  system properties of hard real time embedded systems. 
  


% In this short paper, we describe
%initial results of an ongoing effort to integrate model checking
%technology into the Copilot RV  framework in order to verify
%our monitors before they are deployed in unltra-critical systems.  

%As interest grows in techniques such as
%adaptive flight control and fully autonomous vehicles that utilize
%learning to adapt to unpredictable environments, architectures have
%been proposed~\cite{XX} that use RV to switch from the more exotic
%uncertified software to a certified, but less capable, system when
%safety properties are violated.




