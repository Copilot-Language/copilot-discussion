\section{Correct monitors} \label{sec:codecorrect} 
 RV frameworks employ sophisticated algorithms to synthesize  monitors
 from specifications. In safety-critical systems, subtle errors in the
 translation process can have potentially catastrophic
 consequences and consequently, a safety case for assured RV must
 provide evidence of the correctness the translation process. 


\paragraph{Challenge} There should be assurance arguments that
executable monitors correctly implement the specification.  The monitor implementation
should not be susceptible to unsafe or undefined behaviors such as
buffer and floating point overflows. 

\paragraph{Copilot Approach}    
The  small  Copilot interpreter can be seen as providing an executable
operational semantics for the Copilot language. The monitor synthesis
process software is more complicated  than the interpreter and
increasing the chance an error will occur.  As reported
in~\cite{pike-icfp-12} , our first efforts in monitor
synthesis assurance were  to support  regression tests for the semantics
of the EDSL using Haskell's QuickCheck~\cite{qc} property testing
engine. Type-correct Copilot programs get randomly generated and
output from the interpreter are compared against the actual
monitor. Quickcheck testing easy to implement and uncovered 
a number of bugs during early development of the monitor synthesis
software. Among those bugs caught were forgotten witnesses needed by
the code generation tools. The testing also highlighted issues
differences in how GHC and Haskell implemented floating point numbers,
without either violating the IEEE floating point standard. 


In order to gain greater assurance of the correctness copilot monitor
synthesis, we recently begin leveraging several static analysis tools
to provide a more rigorous footing to the assurance of Copilot
monitors.  The process of translating a specification into a monitor
transforms an AST of the ``core'' language representation into an SBV
AST.  We then use SBV's C code generation capabilities to create
executable C code.  To facilitate monitor verification, Copilot now
produces Hoare-logic style contracts directly from the Copilot core
representation independent of the monitor generation process. The
contracts are written in the ANSI C Specification Language
(ACSL)~\cite{baudin09acsl}, an assertion language for specifying
behavioral properties of C programs in first-order logic.
Frama-C's~\cite{framac} WP deductive verification engine is employed
to prove that the code does indeed satisfy the contract.   

The translation processes that transforms  a specification  into C monitors will create a number small files
that get linked together. Each file has a contract  with an ACSL 
post-condition that basically specifying the subexpression of the core
AST representation that this function should be  implementing. 
The proofs in Section~\ref{ sec:verispec}  about correctness of the
specification are carried out on the reified specification in Copilot
core. Here we are providing evidence that the monitors do indeed
implement that AST giving confidence that the monitor does indeed
satisfy the correct specification. 

In the case of one of the functions implementing
the horizontal separation below, the annotated code is given as 

%\begin{lstlisting}[frame=single, language=C]
\begin{verbatim}
/*@
 assigns \ nothing;
 ensures \ result == (((ext_ident_double_8) - (((ext_minimal_horizontal_separation) * (ext_minimal_horizontal_separation)))));
*/
SDouble ext_sqrt_9_arg0(const SDouble ext_ident_double_8,
                        const SDouble ext_ownship_position_x,
                        const SDouble ext_intruder_position_x,
                        const SDouble ext_ownship_position_y,
                        const SDouble ext_intruder_position_y,
                        const SDouble ext_minimal_horizontal_separation)
{
  const SDouble s0 = ext_ident_double_8;
  const SDouble s5 = ext_minimal_horizontal_separation;
  const SDouble s6 = s5 * s5;
  const SDouble s7 = s0 - s6;

  return s7;
}
\end{verbatim}
%\end{lstlisting}

\noindent
Frama-C's WP plugin easily proves that the function satisfies the
contract. 

While the current analysis demonstrates a faithful translation from
core language to C code, this analysis perform elides the issues that
arise performing floating point. Applying Frarma-C's abstract
interpretation value analysis plug exposed the need to ensure that
there are no floating point infinite values  or not a number (NaN).
In the case of the \texttt{ext\_sqrt\_9\_arg0} function, the value
analysis produces warnings:
\begin{verbatim}
value] computing for function ext_sqrt_9_arg0 <- sampleExts <- step <- testing.
        Called from driver.c:60.
ext_sqrt_9_arg0.c:41:[kernel] warning: non-finite double value ([-1.79769313486e+308 .. 1.79769313486e+308]):
                  assert \is_finite((double)(s5*s5));
ext_sqrt_9_arg0.c:42:[kernel] warning: non-finite double value ([-1.79769313486e+308 .. 1.79769313486e+308]):
                  assert \is_finite((double)(s0-s6));
ext_sqrt_9_arg0.c:30:[value] Function ext_sqrt_9_arg0: postcondition got status unknown.
\end{verbatim}

indicating that steps must be taken to ensure that the two floating
point operations do not result in errors. We are still investigating
the best way to  handle floating point issues in the context of
Copilot RV.


\paragraph{Assured Turtles  All They Way Down} 
Having assured that the C code implementing the monitor is correct,
how can we be sure that the executable binary code correctly
implements the C program. For Copilot, we have experimented
with using the verified Compcert compiler~\cite{leroy} to generate
binaries.  Unfortunately, Compcert does not yet target many of the
processors used in our experiments limiting its utility.


