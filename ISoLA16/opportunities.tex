\section{Better Together}\label{sec:oportunities} 
High-assurance RV will only become practical if there is accompanying
integrated tool support for verification and validation.  From the
perspective of a researcher in high-assurance RV, engaging with the
communities building static analysis tools and proof engines seems
obvious.  Especially in light of the fact that regulatory bodies that
govern many safety-critical systems are increasingly willing to accept
the analysis produced from such tools as evidence that can be applied to
certification ~\cite{DO333}. Similarly, there are many features of RV
that make it a great target for the tool builder. For instance, there are formal
specifications to work with  and monitor code is generally small and
conforms to coding practices that are friendly to static analysis. 

 
Several of the challenges we have raised for high-assurance RV are
really at the system level. Tools that can assist domain experts in
validating safety properties are sorely needed.  As in our case study,
the safety properties of cyber-physical systems are involve continuous
mathematics. While advances in \textsc{smt} solvers have been
impressive, it is still necessary to often resort to using an  interactive
theorem prover. There are many opportunities to design
domain specific decision procedures that would increase the utility of
automated proof
tools.  

The problem of RV observability provides a rich source of problems for tool builders. If the RV
approach involves instrumenting code, then static analysis can both
assist in the instrumentation and prove that the instrumentation did
not affect the correctness of the code. If sampling, static analysis
has the potential to inform when to sample.

Floating point arithmetic is a source of problems that is readily
amenable to static analysis and proof. In our work, we applied
abstract interpretation to monitor source code, but analysis could be
done at the specification level with proof obligations flowing down to
the monitor code.

Applying tools to verify monitor correctness makes so much sense that
it should be de rigueur.  In Copilot, we applied deductive
verification to verify the correctness of the translation from
specification to monitor code.  Monitors have many characteristics
that make automatic proofs tractable, but the monitor synthesis must
generate code that suitable for the tool being used.   