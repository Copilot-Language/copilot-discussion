%\documentclass[draft, twocolumn, landscape, a4paper, fleqn, 10pt]{article}
\documentclass[]{article}

%\usepackage[top=4cm, bottom=4cm, left=4cm, right=4cm]{geometry}
%\usepackage{2in1}
%\usepackage{a4wide}
%\setlength{\columnsep}{1cm}

\newcommand{\todo}[1]{{\bf \Huge !!!!! #1 !!!!!}}
%\usepackage[british]{babel}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{setspace}
\onehalfspacing
\usepackage{framed}
\usepackage[usenames,dvipsnames]{color}
\usepackage[titles]{tocloft}
\setlength{\cftbeforesecskip}{0.1ex}
\renewcommand{\cftsecfont}{\rm}
\renewcommand{\cftsubsecfont}{\rm}
\renewcommand{\cftdot}{\ensuremath{\dots}}
\renewcommand{\cftsecdotsep}{3}
\renewcommand{\cftsubsecdotsep}{3}
\renewcommand{\cftsecpagefont}{\sl}
\renewcommand{\cftsubsecpagefont}{\sl}
\usepackage{sectsty}
\sectionfont{\large\it\centering}
\subsectionfont{\normalsize\it\centering}
\usepackage{listings}
\usepackage{natbib}
\usepackage{fancyvrb}

% boxes around figs
\usepackage{float}
\floatstyle{boxed} 
\restylefloat{figure}


\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\footnotesize}

\lstset{basicstyle=\tt\footnotesize}

\lstdefinelanguage{Haskell}
	{
		morekeywords={as, case, of, class, data, data, family, data, instance,
		default, deriving, do, forall, foreign, hiding, if, then, else, import,
		infix, infixl, infixr, let, in, mdo, module, newtype, proc, qualified,
		rec, type, where},
    	morecomment=[l]{--},
    	morecomment=[s]{{\{-}{-\}}},
    	morestring=[b]",
    	keywordstyle=\color{blue}\bf,
    	commentstyle=\it\color{ForestGreen},
    	stringstyle=\color{red},
    	literate= {<-}{{$\leftarrow$}}1 {->}{{$\rightarrow$}}1 {-<}{{$\prec$}}1
    	{=>}{{$\Rightarrow$}}1 {>>>}{{$\ggg$}}2 {<<<}{{$\lll$}}2 {***}{{$\times$}}1
    	{&&&}{{$\otimes$}}1  {'a}{{$\alpha$}}1 {'b}{{$\beta$}}1 {'c}{{$\gamma$}}1
    	{'d}{{$\delta$}}1 {'e}{{$\eta$}}1
    }

\newtheoremstyle{example}{\topsep}{\topsep}
     {\normalsize\sl} % Body font.
     {}               % Indent amount (empty = no indent, \parindent = para indent).
     {\small\it}      % Thm head font.
     {:}              % Punctuation after thm head.
     {\newline}       % Space after thm head (\newline = linebreak).
     {\thmname{#1} \thmnumber{#2}\thmnote{#3}} % Thm head spec.
\theoremstyle{example}
\newtheorem{example}{Example}

\newcommand{\hlinepage}{\rule{\textwidth}{0.25pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.25pt}}
\newcommand{\fixme}[1]{\emph{\color{Red}\{!~#1~!\}}}

\begin{document}

\thispagestyle{empty}

\begin{center}

The National Institute of Aerospace / Galois Inc. / NASA LaRC

\vspace{0.1cm}

\HRule

\vspace{0.6cm}

{\Huge \bfseries
An Introduction to Copilot
}
\HRule

\vspace{0.6cm}

\begin{minipage}{0.3\textwidth}
\large
\begin{center}
Nis N. Wegmann\\
\small{
niswegmann@gmail.com\\
}
\end{center}
\end{minipage}
\begin{minipage}{0.3\textwidth}
\large
\begin{center}
Lee Pike\\
\small{
leepike@galois.com\\
}
\end{center}
\end{minipage}
\begin{minipage}{0.3\textwidth}
\large
\begin{center}
Sebastian Niller\\
\small{
sebastian.niller@nianet.org\\
}
\end{center}
\end{minipage}

\vspace{1cm}

{\large
Hampton, Virginia, United States, \today
}

%\begin{tabular}{cc}
%\hspace{0.5cm}\includegraphics[width=0.18\textwidth]{figures/nia}\hspace{0.5cm}  &
%\hspace{0.5cm}\includegraphics[width=0.2\textwidth]{figures/galois}\hspace{0.5cm} &
%\hspace{0.5cm}\includegraphics[width=0.2\textwidth]{figures/nasa}\hspace{0.5cm} \\
%\textsc{\large NIA} &
%\textsc{\large Galois Inc.} &
%\textsc{\large NASA LaRC} \\
%\end{tabular}

\let\thefootnote\relax\footnotetext{
This research is supported by NASA Contract NNL08AD13T from the Aviation Safety
Program Office.
}

\end{center}

\vspace{0.25cm}

\section*{Abstract}

{
\small
This document contains a tutorial on Copilot and its accompanying tools.
We do not attempt to give a complete, formal description of Copilot
(references are provided in the bibliography), rather we aim at
demonstrating the fundamental concepts of the language by using idiomatic
expositions and examples.
}

{
\small
\setcounter{tocdepth}{2}
\tableofcontents
}

\newpage

% -----------------------------------------------------------------
% for final report
% -----------------------------------------------------------------

\section{Preliminaries}
\label{sec:preliminaries}

Copilot is embedded into the functional programming language Haskell
\cite{PeytonJones02}.  A working knowledge of Haskell is necessary to use
Copilot effectively; a variety of books and free web resources introduce Haskell.
Copilot uses Haskell language extensions
specific to the Glasgow Haskell Compiler (GHC); hence in order to start
using Copilot, you must first install an up-to-date version of GHC.
(The minimal required version is 7.0.)
The easiest way to do this is to download and install the Haskell Platform,
which is freely distributed from here:

\begin{center}
\url{http://hackage.haskell.org/platform}
\end{center}

\noindent After having installed the Haskell Platform, Copilot is downloaded and
installed by executing the following command:

\begin{code}
> cabal install copilot
\end{code}

\noindent This should, if everything goes well, install Copilot on your system.

Copilot is distributed throughout a series of packages at Hackage:

\begin{itemize}
\item copilot-language: Contains the language front-end.
\item copilot-core: Contains an intermediate representation for Copilot programs (shared by all back-ends).
\item copilot-c99: A back-end for Copilot targeting C99 (based on Atom, \url{http://hackage.haskell.org/package/atom}).
\item copilot-sbv: A back-end for Copilot targeting C99 (based on SBV, \url{http://hackage.haskell.org/package/sbv}).
\item copilot-libraries: A set of utility functions for Copilot, including a clock-library, a linear temporal logic framework,
a voting library, and a regular expression framework.
\item copilot-cbmc: A driver for proving the correspondence between code
  generated by the copilot-c99 and copilot-sbv back-ends.
\end{itemize}

Many of the examples in this paper can be found at
\url{https://github.com/leepike/Copilot/tree/copilot2.0/Examples}.

To use the language, your Haskell module should contain the following import:
%
\begin{code}
import Language.Copilot  
\end{code}
%
To use the back-ends, import, them, respectively:
%
\begin{code}
import Copilot.Compile.C99
import Copilot.Compile.SBV
\end{code}
%
If you need to use functions defined in the Prelude that are redefined by
Copilot (e.g., arithmetic operators), import the Prelude as qualified:
%
\begin{code}
import qualified Prelude as P  
\end{code}

\section{Domain}

Copilot is a domain-specific language tailored to programming \emph{runtime
monitors} for \emph{hard real-time}, \emph{distributed}, \emph{reactive systems}.
Briefly, a runtime monitor is program that runs concurrently with a target program
with the sole purpose of assuring that the target program behaves in accordance with a
pre-established specification. Copilot is a language for writing such specifications.

A reactive system is a system that responds continuously to its environment.
All data to and from a reactive system is communicated progressively during
execution. Reactive systems differ from transformational systems which transforms
data in a single pass and then terminate, as for example compilers and numerical
computation software.

A hard real-time system is a system that has a statically bounded execution time
and memmory usage.  Typically, hard real-time systems are used in
mission-critical software, such as avionics, medical equipment, and nuclear power
plants; hence, occasional dropouts in the response time or crashes are not
tolerated.

A distributed system is a system which is layered out on multiple pieces of hardware.
The distributed systems we consider are all synchronized, i.e., each component agree on
a shared global clock.

\section{Language}

Copilot is a pure declarative language; i.e., expressions are free of side-effects
and satisfies referential transparency.
A program written in Copilot, which from now on will be referred to as a \emph{specification},
has a cyclic behavior, where each cycle consists of a fixed series of steps:

\begin{itemize}
\item Sample external variables, arrays, and functions.
\item Update internal variables.
\item Fire external triggers. (In case the specification is violated.)
\end{itemize}

\noindent We refer to a single cycle as an \emph{iteration}.

All transformation of data in Copilot is propagated through streams.
A stream is an infinite, ordered sequence of values which must conform to the same type.
E.g. we have the stream of Fibonacci numbers:

\begin{center}
$s_{fib} = \{0, 1, 1, 2, 3, 5, 8, 13, 21, \dots \}$
\end{center}

\noindent We denote the $n$th value of the stream $s$ as $s(n)$, and the first
value in a sequence $s$ as $s(0)$. For example, for $s_{fib}$ we have that $s_{fib}(0) = 1$,
$s_{fib}(1) = 1$, $s_{fib}(2) = 2$, and so forth.

Constants as well as arithmetic, boolean, and relational operators are
lifted to work pointwise on streams:
\\

\noindent
\begin{minipage}{0.3\textwidth}
\begin{code}
x :: Stream Int32
x = 5 + 5
\end{code}
\end{minipage}
\begin{minipage}{0.3\textwidth}
\begin{code}
y :: Stream Int32
y = x * x
\end{code}
\end{minipage}
\begin{minipage}{0.3\textwidth}
\begin{code}
z :: Stream Int32
z = x == 10 && y < 200
\end{code}
\end{minipage}
\\

\noindent Here the streams {\tt x}, {\tt y}, and {\tt z} are simply
\emph{constant streams}:

\begin{center}
$\mathtt{x} \leadsto \{10, 10, 10, \dots \}$,
$\mathtt{y} \leadsto \{100, 100, 100,  \dots \}$,
$\mathtt{z} \leadsto \{\mbox{T},\; \mbox{T},\; \mbox{T},\; \dots \}$
\end{center}

Two types of \emph{temporal} operators are provided, one for delaying streams and one for
looking into the future of streams:
%
\begin{code}
(++) :: [a] -> Stream a -> Stream a
drop :: Int -> Stream a -> Stream a
\end{code}
%
Here {\tt xs ++ s} prepends the list {\tt xs} at the front of the stream {\tt s}.
For example the stream {\tt w} defined as follows, given our previous definition
of {\tt x}:
%
\begin{code}
w = [5,6,7] ++ x
\end{code}
%
evaluates to the sequence
$\mathtt{w} \leadsto \{5, 6, 7, 10, 10, 10, \dots\}$.
The expression {\tt drop k s} skips the first {\tt k} values of the stream {\tt
  s}, returning the remainder of the stream.  
For example we can skip the first two values of {\tt w}:
%
\begin{code}
u = drop 2 w
\end{code}
%
which yields the sequence
$\mathtt{u} \leadsto \{7, 10, 10, 10, \dots\}$.

\subsection{Streams as Lazy-lists}

A key design choice in Copilot is that streams should mimic \emph{lazy lists}.
In Haskell, the lazy-list of natural numbers can be programmed like this:
%
\begin{code}
nats_ll :: [Int32]
nats_ll = [0] ++ zipWith (+) (repeat 1) nats_ll
\end{code}
%
As both constants and arithmetic operators are lifted to work pointwise on
streams in Copilot, there is no need for {\tt zipWith} and {\tt repeat} when
specifying the stream of natural numbers:
%
\begin{code}
nats :: Stream Int32
nats = [0] ++ (1 + nats)
\end{code}
%
In the same manner, the lazy-list of Fibonacci numbers can be specified as follows:
%
\begin{code}
fib_ll :: [Int32]
fib_ll = [1, 1] ++ zipWith (+) fib_ll (drop 1 fib_ll)
\end{code}
%
In Copilot we simply throw away {\tt zipWith}:
\begin{code}
fib :: Stream Int32
fib = [1, 1] ++ (fib + drop 1 fib)
\end{code}

Copilot specifications must be \emph{causal}, informally meaning that
stream values cannot depend on future values.  For example, the following stream
definition is allowed:
%
\begin{code}
h :: Stream Word64
h = drop 2 g
  where g = f
        f = [0,1,2] ++ f
\end{code}
%

But if instead {\tt h} is defined as {\tt h = drop 4 g}, then the definition is
disallowed.  While an analogous stream is definable in a lazy language, we bar
it in Copilot, since it requires future values of {\tt g} and {\tt f} to be
generated before producing values for {\tt h}.  This is not possible since
Copilot programs may take inputs in real-time from the environment (see
Section~\ref{sec:interacting}).

\subsection{Functions on Streams}

Given that constants and operators work pointwise on streams, we can use Haskell
as a macro-language for defining functions on streams.  The idea of using
Haskell as a macro language is powerful, since Haskell is a
general-purpose higher-order functional language.

\begin{example}
We define the function, {\tt even}, which given a stream of
integers returns a boolean stream which is true whenever the input stream
contains an even number, as follows:
%
\begin{code}
even :: Stream Int32 -> Stream Bool
even x = x `mod` 2 == 0
\end{code}
%
Applying {\tt even} on {\tt nats} (defined above) yields the sequence
$\{T, F, T, F, T, F, \dots\}$.
\end{example}

If a function is required to return multiple results, we simply use plain
Haskell tuples:

\begin{example}
We define complex multiplication as follows:
%
\begin{code}
mul_comp
  :: (Stream Double, Stream Double)
  -> (Stream Double, Stream Double)
  -> (Stream Double, Stream Double)
(a, b) `mul_comp` (c, d) = (a * c - b * d, a * d + b * c)
\end{code}
%
Here {\tt a} and {\tt b} represent the real and imaginary part of the left
operand, and {\tt c} and {\tt d} represent the real and imaginary part
of the right operand.
\end{example}

\subsection{Stateful Functions}

In addition to pure functions, such as {\tt even} and {\tt mul\_comp},
Copilot also facilitates \emph{stateful} functions. A \emph{stateful} function
is function which has an internal state, e.g. as a latch (as in electronic
circuits) or a low/high-pass filter (as in a DSP).

\begin{figure}
\begin{minipage}{0.4\linewidth}
\begin{tabular}{c|c||c}
$\mathtt{x}_i$: & $\mathtt{y}_{i-1}$: & $\mathtt{y}_i$:\\
\hline
$F$ & $F$ & $F$ \\
\hline
$F$ & $T$ & $T$ \\
\hline
$T$ & $F$ & $T$ \\
\hline
$T$ & $T$ & $F$
\end{tabular}
\end{minipage}
\hspace{1cm}
\begin{minipage}{0.6\linewidth}
\begin{code}
latch :: Stream Bool -> Stream Bool
latch x = y
  where
  y = if x then not z else z
    where
    z = [False] ++ y
\end{code}
\end{minipage}
\caption{A latch. The specification is provided at the left and the
implementation is provided at the right.}
\label{fig:jk_latch}
\end{figure}

\begin{example}
We consider a simple latch, as described in \cite{Farhat2004}, with a single
input and a boolean state. Whenever the input is true the internal state is reversed.
The operational behavior and the implementation of the latch is shown in Figure
\ref{fig:jk_latch}.\footnote
{In order
to use conditionals (if-then-else's) in Copilot specifications,
as in Figure \ref{fig:jk_latch},
or guards, as in Figure \ref{fig:counter}, the GHC
language extension {\tt RebindableSyntax} must be set on.}
\end{example}

\begin{figure}
\begin{minipage}{0.4\linewidth}
\begin{tabular}{c|c||c}
$\mathtt{inc}_i$: & $\mathtt{reset}_i$: & $\mathtt{cnt}_i$: \\
\hline
$F$ & $F$ & $\mathtt{cnt}_{i-1}$ \\
\hline
$F$ & $T$ & $0$ \\
\hline
$T$ & $F$ & $\mathtt{cnt}_{i-1} + 1$ \\
\hline
$T$ & $T$ & $0$
\end{tabular}
\end{minipage}
\hspace{1cm}
\begin{minipage}{0.6\linewidth}
\begin{code}
counter :: Stream Bool -> Stream Bool 
        -> Stream Int
counter inc reset = cnt
  where
    cnt | reset     = 0
        | inc       = z + 1
        | otherwise = z
    z = [0] ++ cnt
\end{code}
\end{minipage}
\caption{A resettable counter. The specification is provided at the left and the
implementation is provided at the right.
}
\label{fig:counter}
\end{figure}

\begin{example}
We consider a resettable counter with two inputs, {\tt inc} and {\tt reset}.
The input {\tt inc} increments the counter and the input {\tt reset} resets the
counter. The internal state of the counter, {\tt cnt}, represents the value of the
counter and is initially set to zero. At each cycle, $i$, the value of
$\mathtt{cnt}_i$ is determined as shown in the left table in Figure
\ref{fig:counter}.
\end{example}

%\begin{figure}
%\begin{code}
%fir2pole :: Double -> Double -> Double -> Double
%  -> Double -> Sig Double -> Sig Double
%fir2pole a1 a2 b0 b1 b2 x0 = y0
%  where
%    y0 = - (constant a1)*y1 - (constant a2)*y2
%         + (constant b0)*x0 + (constant b1)*x1 + (constant b2)*x2
%    x2 = [0, 0] ++ x0 ; x1 = drop 1 x2
%    y2 = [0, 0] ++ y0 ; y1 = drop 1 y2
%\end{code}
%\caption{A $2$-pole IIR filter.}
%\label{fig:2_pole_iir_filter}
%\end{figure}

\subsection{Types}

Copilot is a typed language, where types are enforced by the Haskell type system
to ensure generated C programs are well-typed.  Copilot is \emph{strongly typed}
(i.e., type-incorrect function application is not possible) and \emph{statically
  typed} (i.e., type-checking is done at compile-time).  The base types are
Booleans, unsigned and signed words of width 8, 16, 32, and 64, floats, and
doubles.\footnote{Floats and doubles are supported by the Atom back-end but not
  the SBV back-end.}  All elements of a stream must belong to the same base
type.  These types have instances for the class {\tt Typed a}, used to constrain
Copilot programs.

We provide a {\tt cast} operator
%
\begin{code}
cast :: (Typed a, Typed b) => Stream a -> Stream b  
\end{code}
%
that casts from one type to another.  The cast operator is only defined for
casts that do not lose information, so an unsigned word type {\tt a} can only be cast to another unsigned  type at least as large as {\tt a} or to a signed word type
strictly larger than {\tt a}.  Signed types cannot be cast to unsigned types but
can be cast to signed types at least as large.

\subsection{Interacting With the Target Program}
\label{sec:interacting}

All interaction with the outside world is done by sampling \emph{external
  variables} and by evoking \emph{triggers}.  External variables are variables
that are defined outside Copilot and which reflect the visible state of the
target program that we are monitoring.  Analogously, triggers are functions that
are defined outside Copilot and which are evoked when Copilot needs to report
that the target program has violated a specification constraint.

External variables are defined by using the {\tt extern} construct:
%
\begin{code}
extern :: Typed a => String -> Stream a
\end{code}
%
\noindent
It takes the name of an external variable and generates a stream by sampling
the variable at each clock cycle.  For example, 
%
\begin{code}
sumExterns :: Stream Word64
sumExterns = let ex1 = extern "e1"
                 ex2 = extern "e2"
             in  ex1 + ex2
\end{code}
%
is a stream that takes two external variables {\tt e1} and {\tt e2} and adds
them.  Sometimes, type inference cannot infer the type of an external variable.  For
example, in the stream definition
%
\begin{code}
extEven :: Stream Bool
extEven = extern "x" `mod` 2 == 0
\end{code}
%
the type of {\tt extern "x"} is ambiguous.  For convenience, typed {\tt extern}
functions are provided, e.g., {\tt externW8} or {\tt externI64} denoting an
external unsigned 8-bit word or signed 64-bit word, respectively.

Triggers are defined by using the {\tt trigger construct}:
%
\begin{code}
trigger :: String -> Stream Bool -> [TriggerArg] -> Spec
\end{code}
%
The first parameter is the name of the external function, the second parameter is the
guard which determines when the trigger should be evoked, and the third parameter
is a list of arguments which is passed to the trigger when evoked.
Triggers can be combined into a specification by using the \emph{do}-notation:
%
\begin{code}
spec :: Spec
spec = do
  trigger "f" (even nats) [arg fib, arg (nats * nats)]
  trigger "g" (fib > 10) []
  let x = externW32 "x" 
  trigger "h" (x < 10) [arg x]
\end{code}
%
The order in which the triggers are defined is irrelevant.

\begin{example}
\label{exm:engine}
We consider an engine controller with the following property:
If the temperature rises more than 2.3 degrees within 0.2 seconds, then
the engine should be shut off immediately.
Assuming that the global sample rate is 0.2 seconds, we can define a monitor that
surveys the above property:
%
\begin{code}
propTempRiseShutOff :: Spec
propTempRiseShutOff = trigger "over_temp_rise" (overTempRise ==> not running) []
  where
  temps        = [0, 0, 0] ++ (extern "temp" :: Stream Float)
  overTempRise = drop 2 temps > const 2.3 + temps
  running      = extern "running"

\end{code}
%
Here, we assume that the external variable {\tt temp} denotes the temperature of the
engine and the external variable {\tt running} indicates whether the engine is running.
The external function {\tt over\_temp\_rise} is called without any arguments if the
temperature rises more than 2.3 degrees within 0.2 seconds and the engine is not shut
off.
\end{example}

Besides variables, external arrays and arbitrary functions can be sampled.  The
external array construct has the type
%
\begin{code}
externArray :: (Typed a, Typed b, Integral a) 
            => String -> Stream a -> Stream b  
\end{code}
%
The construct takes the name of an array and a stream that generates indexes for
the array (of integral type).  For example,
%
\begin{code}
extArr :: Stream Word32
extArr = externArray "arr1" arrIdx
  where 
  arrIdx :: Stream Word8
  arrIdx = [0] ++ (arrIdx + 1) `mod` 4
\end{code}
{\tt extArr} is a stream of values drawn from an external array containing
32-bit unsigned words.  The array is indexed by an 8-bit variable.  The index
is ensured to be less than four by using modulo arithmetic.
%% %
%% \begin{code}
%% externArray :: (Typed a, Typed b, Integral a) => String -> Stream a -> Stream b
%% externFun :: Typed a => String -> [FunArg] -> Stream a
%% funArg :: Typed a => Stream a -> FunArg
%% \end{code}
%% % 
%% The constructor \texttt{externArray} takes two arguments: the name of array and
%% an index into the array.  The index is given by a Copilot stream (of integral
%% type) that is used as an index into the table.

%
\begin{example}
\label{exm:e}
Say we have defined a lookup-table (in C99) of a discretized continuous function that we want to use
within Copilot:
%
\begin{code}
double someTable[] = { 3.5, 3.7, 4.5, ... };
\end{code}
%
We can use the table in a Copilot specification as follows:
%
\begin{code}
lookupSomeTable :: Stream Int -> Stream Stream Double
lookupSomeTable k = externArray "someTable" k 
\end{code}
%
Given the following values for \texttt{k}, $\{1, 0, 2, 2, 1, \dots \}$, the output of 
\texttt{lookupSomeTable k} would be $\{3.7, 3.5, 4.5, 4.5, 3.7, \dots \}$.
\end{example}

The constructor \texttt{externFun} also takes two arguments: the name of the
external function and a list of arguments that are provided to the
function. 
%
\begin{code}
externFun :: Typed a => String -> [FunArg] -> Stream a
\end{code}
%
Each argument to an external function is given by a Copilot stream.  For
example,
%
\begin{code}
func :: Stream Word16
func = externFun "f" [funArg $ externW8 "x", funArg nats]
  where
  nats :: Stream Word16
  nats = [0] ++ nats + 1
\end{code} 
% $
samples a function in C that has the prototype
%
\begin{code}
uint16_t f(uint8_t x, uint16_t nats);
\end{code}
%
Both external arrays and functions must, like external variables, be defined in
the target program that is monitored. Additionally external functions must be
without side effects, as the monitor can cause undesired side-effects when
calling the function.


\subsection{Explicit Sharing}
\label{sec:explicit_sharing}

\begin{figure}[ht]
\begin{minipage}{0.5\textwidth}
\begin{code}
s1 = let x = nats + nats
     in x * x
\end{code}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{code}
s2 = local (nats * nats) $
    \ x -> x + x
\end{code} 
% $
\end{minipage}
\caption{Implicit sharing (to the left) versus explicit sharing (to the right).}
\label{fig:explicit_sharing}
\end{figure}
\noindent Copilot facilitates sharing in expressions by the \emph{local}-construct:
%
\begin{code}
local
  :: (Typed a, Typed b)
  => Stream a
  -> (Stream a -> Stream b)
  -> Stream b
\end{code}
%
The local construct works similar to \emph{let}-bindings in ordinary Haskell.
From a semantic point of view, the streams {\tt s1} and {\tt s2} from Figure
\ref{fig:explicit_sharing} are identical.
As we will see in Section~\ref{subsec:boyer_moore}, however, certain advanced
Copilot programs may force the compiler to build syntax trees that blow up exponentially.
In such cases, using explicit sharing helps to avoid this problem.

\section{Tools}

Copilot comes with a variety of tools, including a pretty-printer, an interpreter,
a two compilers targeting C, and a verifier front-end. In the following section, we will
demonstrate some of these tools and their usage.

\subsection{Pretty-Printing}
Pretty-printing is straightforward.  For some specification {\tt spec},
%
\begin{code}
prettyPrint spec
\end{code}
%
\noindent
returns the specification after static macro expansion.  Pretty-printing can
provide some indication about the complexity of the specification to be
evaluated.  Specifications that are built by recursive Haskell programs (e.g.,
the majority voting example in Section~\ref{subsec:boyer_moore}) can generate
expressions that are quite large.  Very large expressions can take significant
time to interpret or compile.

\subsection{Interpreting Copilot}

Suppose we want to interpret the engine controller from Example \ref{exm:engine}.
Before we can do so, we must define the external variables {\tt temp}
and {\tt running} as infinite Haskell lists:
%
\begin{code}
temp :: [Float]
temp = map exp [0.2, 0.4 ..]

running :: [Bool]
running = repeat True
\end{code}
%
We now evoke the interpreter as follows (e.g. in GHCI, the GHC compiler's
interpreter for Haskell):
%
\begin{code}
GHCI> interpret 10
                [var "temp" temp, var "running" running]
                propTempRiseShutOff
\end{code}
%
The first argument to the function \emph{interpret} is the number of iterations that we want to evaluate.
The second argument is a list of inputs. Each input takes a name and an infinite list of
values (which must conform to the type of the input). The third argument is the specification
that we wish to interpret.

If a Copilot program contains no external variables, then {\tt interpret} is
given the empty list {\tt []}.

The interpreter outputs the values of the arguments passed to the trigger, if
its guard is true, and {\tt --} otherwise.  For example, consider the following
Copilot program:
%
\begin{code}
spec = do 
  trigger "trigger1" (even nats) [arg nats, arg $ odd nats]
  trigger "trigger2" (odd nats) [arg nats]
\end{code}
% $
where {\tt nats} is the stream of natural numbers, and {\tt even} and {\tt odd}
are functions that take a stream and return whether the point-wise values are
even or odd, respectively.  The output of 
%
\begin{code}
interpret 10 [] spec
\end{code}
%
is as follows:
%
\begin{code}
trigger:   trigger2: 
(0,false)  --        
--         (1)       
(2,false)  --        
--         (3)       
(4,false)  --        
--         (5)       
(6,false)  --        
--         (7)       
(8,false)  --        
--         (9)     
\end{code}
%


In programs containing external arrays, an infinite \emph{list of lists} is
given, simulating how the array changes in each tick.  For example, for a
program containing an array {\tt arr} of unsigned 32-bit integers, of length
four, we can define {\tt arrInterp} 
%
\begin{code}
arrInterp :: [Word32]
arrInterp = 
  let shiftl ls = ls : shiftl (tail ls ++ [head ls]) in
  shiftl [0..3]
\end{code}
%
to generate the list 
%
\begin{code}
[[0,1,2,3],[1,2,3,0],[2,3,0,1],[3,0,1,2] ... ]  
\end{code}
%
We can then use {\tt arrInterp} as an input to simulate the program containing
it.  
%
\begin{code}
interpret 10 [ array "arr" arrInterp ] spec
\end{code}
%
Note that the index into the array must not be greater than three!

External functions can be modeled by a stream that simulates the
behavior of the function.  for example, for an external function that takes an
external variable and a Copilot stream as arguments
%
\begin{code}
func :: Stream Word16
func = externFun "f" [funArg $ externW8 "x", funArg nats]
\end{code}
% $
we can define a stream that also takes an external variable {\tt x} that is an
8-bit unsigned word and the stream {\tt nats}.  Suppose we decide that our simulation
stream adds its two arguments.  To interpret the function, we call
%
\begin{code}
x :: Word8
x = [0..]

interpret 10 [ func "func0" (cast (externW8 "x") + nats)
             , var "x" x ] 
          spec
\end{code}

Sometimes it is convenient to observe the behavior of a stream without defining
a trigger.  We can do so by using an observer.  For example:
%
\begin{code}
spec :: Spec
spec = observer ``obs'' nats  
\end{code}
%
can be interpreted using
%
\begin{code}
interpret 5 [] spec  
\end{code}
%
as usual.  Observers can be combined in larger Copilot programs.  For example,
consider the following:
%
\begin{code}
spec :: Spec
spec = do
  let x = externW8 "x"
  trigger "trigger" true [arg $ x < 3]
  observer "debug_x" x
\end{code}
% $
Interpreting {\tt spec} as follows
%
\begin{code}
interpret 10 [var "x" [0 :: Word8 ..]] foo  
\end{code}
%
yields
%
\begin{code}
trigger:  debug_x: 
(true)    0        
(true)    1        
(true)    2        
(false)   3        
(false)   4        
(false)   5        
(false)   6        
(false)   7        
(false)   8        
(false)   9        
\end{code}
\subsection{Compiling Copilot}

Compiling the engine controller from Example \ref{exm:engine} is
straightforward.  First, we pick a back-end to compile to (see
Section~\ref{sec:preliminaries} for a brief list of back-ends; we compile to Atom
below), import it, and
compile as follows:\footnote{Two explanations are in order: (1) {\tt reify} is
an optimization that improves sharing in the expressions to be compiled,
improving efficiency~\cite{DSLExtract}, and {\tt >>=} is a higher-order operator that takes the
result of reification and ``feeds'' it to the compile function.}
%
\begin{code}
reify spec >>= compile defaultParams
\end{code}
%
\noindent
(The compile function takes a parameter to rename the generated C files; {\tt
  defaultParams} is the default, in which there is no renaming.)

The compiler now generates two files:

\begin{itemize}
\item ``copilot.c'' --- 
\item ``copilot.h'' --- 
\end{itemize}

The file named ``copilot.h'' contains prototypes for all external variables, functions, and arrays,
and contains a prototype for the ``step''-functions which evaluates a single iteration.

\begin{code}
/* Generated by Copilot Core v. 0.1 */

#include <stdint.h>
#include <stdbool.h>

/* Triggers (must be defined by user): */

void over_temp_rise();

/* External variables (must be defined by user): */

extern float temp;
extern bool running;

/* Step function: */

void step();
\end{code}

Using the prototypes in ``copilot.h'' we can build a driver as follows:

\begin{code}
/* driver.c */
#include <stdio.h>
#include "copilot.h"

bool running = true;
float temp = 1.1;

void over_temp_rise()
{
  printf("The trigger has been evoked!\n");
}

int main (int argc, char const *argv[])
{
  int i;

  for (i = 0; i < 10; i++)
  {
    printf("iteration: %d\n", i);
    temp = temp * 1.3;
    step();
  }

  return 0;
}
\end{code}

Running ``gcc copilot.c driver.c -o prop'' gives a program ``prop'', which when executed
yields the following output:
%
\begin{code}
iteration: 0
iteration: 1
iteration: 2
iteration: 3
iteration: 4
iteration: 5
iteration: 6
iteration: 7
The trigger has been evoked!
iteration: 8
The trigger has been evoked!
iteration: 9
The trigger has been evoked!
\end{code}
%

\subsection{QuickCheck}
QuickCheck~\cite{qc} is a library originally developed for Haskell such that
given a property, it generates random inputs to test the property.  We provide a
similar tool for checking Copilot specifications.  Currently, the tool is
implemented to check the copilot-c99 back-end against the interpreter.  The tool
generates a random Copilot specification, and for some user-defined number of
iterations, the output of the interpreter is compared against the output of the
compiled C program.  The user can specify weights to influence the probability
at which expressions are generated.

If you have installed Copilot, you can execute the quickCheck tests by executing
the program {\tt CopilotC99Test}.  The default installation for the executable
is in {\tt \$HOME/.cabal/bin}. Assuming the executable is in your path, simply
execute it.  It will direct the user to enter the number of specifications to
test.  The program will then generate that many random specifications, testing
the output of the interpreter against the executed C program.  By default, it
tests the outputs for ten iterations.


\subsection{Verification}
``Who watches the watchmen?''  Nobody.  For this reason, monitors in
ultra-critical systems are the last line of defense and cannot fail.  Here, we
outline our approach to generate high-assurance monitors.  First, as mentioned,
the compiler is statically and strongly typed, and by implementing an eDSL, much
of the infrastructure of a well-tested Haskell implementation is reused.  We
have described our custom QuickCheck engine.  We have tested millions of
randomly-generated programs between the compiler and interpreter with this approach.

Additionally, Copilot includes a tool to generate a driver to prove the
equivalence between the copilot-c99 and copilot-sbv back-ends that each generate
C~code (similar drivers are planned for future back-ends).  To use the driver,
first import the following module:
%
\begin{code}
import qualified Copilot.Tools.CBMC as C
\end{code}
%
\noindent
(We import it using the {\tt qualified} keyword to ensure no name space
collisions.)  Then in GHCI, just like with compilation, we execute
%
\begin{code}
reify spec >>= C.genCBMC C.defaultParams  
\end{code}
%
\noindent
This generates two sets of C sources, one compiled through the copilot-c99
back-end and one through the copilot-sbv back-end.  In addition, a driver (that is, a
{\tt main} function) is generated that executes the code from each back-end.  The
driver has the following form:
%
\begin{code}
int main (int argc, char const *argv[])
{
  int i;

  for (i = 0; i < 10; i++)
  {
    sampleExterns();
    atm_step();
    sbv_step();
    assert(atm_i == sbv_i);
  }

  return 0;
}
\end{code}
%
This driver executes the two generated programs for ten iterations, which is the
default value.  That default can be changed; for example:
%
\begin{code}
reify spec >>= 
  C.genCBMC C.defaultParams {C.numIterations = 20}
\end{code}
%
\noindent
The above executes the generated programs for 20 executions.

The verification depends on an open-source model-checker for C source-code
originally developed at Carnegie Mellon University~\cite{cbmc}.  A license for
the tool is available.~\footnote{\url{http://www.cprover.org/cbmc/LICENSE}.  It
  is the user's responsibility to ensure their use conforms to the license.}
CBMC must be downloaded and installed separately; CBMC is actively maintained
at the time of writing, and is available for Windows, Linux, and Mac OS.

CBMC symbolically executes a program.  With different options, CBMC can be used
to check for arithmetic overflow, buffer overflow/underflow, floating-point NaN
results, and division by zero.  Additionally, CBMC can attempt to verify
arbitrary {\tt assert()} statements placed in the code.  In our case, we wish to
verify that on each iteration, for the same input variables, the two back-ends
have the same state.  

CBMC proves that for all possible inputs, the two programs have the same outputs
for the number of iterations specified.  The time-complexity of CBMC is
exponential with respect to the number of iterations.  Furthermore, CBMC cannot
guarantee equivalence beyond the fixed number of iterations.

After generating the two sets of C source files, CBMC can be executed on the
file containing the driver; for example,
%
\begin{code}
cbmc cbmc_driver.c  
\end{code}
%

\section{Extended Example: The Boyer-Moore Majority-Vote Algorithm}
\label{subsec:boyer_moore}

In this section we demonstrate how to use Haskell as an advanced macro language
on top of Copilot by implementing an algorithm for solving the voting problem
in Copilot.

\begin{figure}
\begin{code}
majorityPure :: Eq a => [a] -> a
majorityPure []     = error "majorityPure: empty list!"
majorityPure (x:xs) = majorityPure' xs x 1

majorityPure' []     can _   = can
majorityPure' (x:xs) can cnt =
  let
    can' = if cnt == 0 then x else can
    cnt' = if cnt == 0 || x == can then succ cnt else pred cnt
  in
    majorityPure' xs can' cnt'
\end{code}
\caption{The first pass of the majority vote algorithm in Haskell.}
\label{fig:majority_pure}
\end{figure}

\begin{figure}
\begin{code}
aMajorityPure :: Eq a => [a] -> a -> Bool
aMajorityPure xs can = aMajorityPure' 0 xs can > length xs `div` 2

aMajorityPure' cnt []     _   = cnt
aMajorityPure' cnt (x:xs) can =
  let
    cnt' = if x == can then cnt+1 else cnt
  in
    aMajorityPure' cnt' xs can
\end{code}
\caption{The second pass of the majority vote algorithm in Haskell.}
\label{fig:amajority_pure}
\end{figure}

Reliability in mission critical software is often improved by replicating
the same computations on separate hardware and by doing a vote in the end
based on the output of each system. The majority vote problem consists of
determining if in a given list of votes there is a candidate that has more
than half of the votes, and if so, of finding this candidate.

The Boyer-Moore Majority Vote Algorithm \cite{MooreBoyer82, Hesselink2005}
solves the problem in linear time and constant memory. It does so in two passes:
The first pass eliminates every, but a single, candidate; and the second pass
asserts that the found candidate indeed holds a majority.

Without going into details of the algorithm (references are provided in the
bibliography), the first pass can be implemented in Haskell as shown in Figure
\ref{fig:majority_pure}. The second pass, which simply checks that a candidate
has more than half of the votes, is straightforward to implement and is shown
in Figure \ref{fig:amajority_pure}.
E.g. applying {\tt majorityPure} on the string {\tt AAACCBBCCCBCC} yields
{\tt C}, which {\tt aMajorityPure} can confirm is in fact a majority.

\begin{figure}[ht]
\begin{code}
majority :: (Eq a, Typed a) => [Stream a] -> Stream a
majority []     = error "majority: empty list!"
majority (x:xs) = majority' xs x 1

majority' []     can _   = can
majority' (x:xs) can cnt =
  local
    (if cnt == 0 then x else can) $
      \ can' ->
        local (if cnt == 0 || x == can then cnt+1 else cnt-1) $
          \ cnt' ->
            majority' xs can' cnt'
\end{code}
\caption{The first pass of the majority vote algorithm in Copilot.}
\label{fig:majority}
\end{figure}

\begin{figure}[ht]
\begin{code}
aMajority :: (Eq a, Typed a) => [Stream a] -> Stream a -> Stream Bool
aMajority xs can = aMajority' 0 xs can > (fromIntegral (length xs) `div` 2)

aMajority' cnt []     _   = cnt
aMajority' cnt (x:xs) can =
  local
    (if x == can then cnt+1 else cnt) $
      \ cnt' ->
        aMajority' cnt' xs can
\end{code}
\caption{The second pass of the majority vote algorithm in Copilot.}
\label{fig:amajority}
\end{figure}
% $

When implementing the majority vote algorithm for Copilot, we can use reuse
almost all of the code from the Haskell implementation. However, as functions
in Copilot in reality are macros that are expanded at compile time, care must
be taken in order to avoid an explosion in the code size. Hence, instead of
using Haskell's built-in \emph{let}-blocks, we use explicit sharing, as
described in Section~\ref{sec:explicit_sharing}. The Copilot implementations
of the first and the second pass are given in Figure \ref{fig:majority} and
Figure \ref{fig:amajority} respectively. Comparing the Haskell implementation
with the Copilot implementation, we see that the code is almost identical,
except for the type signatures and the explicit sharing annotations.

% -----------------------------------------------------------------
% for final report
% -----------------------------------------------------------------



\addcontentsline{toc}{section}{Further Reading}
\section*{Further Reading}

For detailed background information on Copilot we refer to \cite{PikeGoodloe2010} and \cite{PikeGoodloe2011}.

\addcontentsline{toc}{section}{Acknowledgement}
\section*{Acknowledgement}

The authors are grateful for NASA Contract NNL08AD13T to Galois Inc. and the
National Institute of Aerospace, which partially supported this work.

{
\addcontentsline{toc}{section}{References}
\bibliographystyle{plainnat}
\bibliography{mybib}
}

\end{document}
