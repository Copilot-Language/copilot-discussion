\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{tabularx}
\usetheme{Frankfurt}
\newcommand\TestAppExists[3]{#2}
\usepackage{minted}
\usepackage{listings}

\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage{tikz-cd}
\usetikzlibrary{positioning}

   
\usepackage{mathpartir}
\usepackage{multicol}
\usepackage{graphicx}



\lstset{ %
	basicstyle=\small\ttfamily,
	breakatwhitespace=true,  
	breaklines=false,        
	commentstyle=\color{green!40!black},   
	extendedchars=true,             
	keepspaces=true,                
	keywordstyle=\color{blue},      
	showspaces=false,               
	showstringspaces=false,         
	showtabs=false,                  
	tabsize=2
}
  
  \setbeamerfont{institute}{size=\fontsize{7pt}{8pt}}
  
  \title{Copilot : Traceability and Verification of a Low Level Automatically Generated C Source Code}
  \author{Georges-Axel Jaloyan}
  \institute{\'Ecole Normale Supérieure, NASA Langley Research center, National Institute of Aerospace}
  \date{August 24, 2015}
  
  \begin{document}
\begin{frame}
  		
  		\titlepage
  		\begin{center}
  			\includegraphics[height=2cm]{images/ENS-logo.jpg} \includegraphics[height=2cm]{images/NASA.png}
  			\includegraphics[height=2cm]{images/NIA-logo.jpg}
  		\end{center}
\end{frame}
  	
  	
  	\section{Preliminaries}
  	\subsection{Copilot language}
\begin{frame}
  		\tableofcontents[currentsubsection,sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
\end{frame}
  	
\begin{frame}
  		\frametitle{Copilot language}
  		Copilot is an \emph{EDSL} (embedded domain specific language), embedded in \emph{Haskell} and used for writing \emph{runtime monitors} for hard real-time, distributed, reactive systems written in C. 
  		\\~\\
  		\text{A Copilot program, can either be : } 
  		\begin{itemize}
  			\item compiled to C using two back-ends : SBV, ATOM
  			\item interpreted
  			\item analyzed using static analysis tools (CBMC, Kind)
  		\end{itemize} 
\end{frame}
  	
\begin{frame}[fragile]
  		\frametitle{Copilot syntax}
  		A program is a list of streams that can be either external  or internal which are defined by mutually recursive stream equations.
  		\\~\\
  		Each stream has a type which can be \texttt{Bool}, \texttt{Int8}, \texttt{Int16}, \texttt{Int32}, \texttt{Int64}, \texttt{Word8}, \texttt{Word16}, \texttt{Word32}, \texttt{Word64}, \texttt{Float}, \texttt{Double}.
  		
\begin{minted}{haskell}
x :: Stream Word16
x = 0
-- x = {0, 0, 0, ...}
y :: Stream Bool
y = x `mod` 2 == 0
-- y = {T, T, ...}
nats :: Stream Word64
nats = [0] ++ (1 + nats)
-- nats = {0,1,2, ..., 2^64-1, 0, 1, ..}  
\end{minted}
\end{frame}
  	
\begin{frame}[fragile]
	\frametitle{Operators}
  		Each operator and constant has been lifted to Streams (working pointwise). \\~\\
  		Two temporal operations working on Streams : 
  		\begin{itemize}
  			\item ++ : which prepends a finite list to a Stream

\begin{minted}{haskell}
(++) :: [a] -> Stream a -> Stream a
\end{minted}
  			\item drop : which drops a finite number of elements at the beginning of a Stream
\begin{minted}{haskell}
drop :: Int -> Stream a -> Stream a  
\end{minted}
  		\end{itemize}
  		
Casts and unsafe casts are also provided :
\begin{minted}{haskell}
cast :: (Typed a, Typed b) => Stream a -> Stream b
unsafeCast :: (Typed a, Typed b) => Stream a -> Stream b
\end{minted}
\end{frame}
  	
\begin{frame}[fragile]
  		\frametitle{Examples}
	Fibonacci sequence :
\begin{minted}{haskell}
fib :: Stream Word64
fib = [1,1] ++ (fib + drop 1 fib) 
-- fib = {1,1,2,3,5,8,13,...,
--       12200160415121876738,
--   /!\ 1293530146158671551,...}
\end{minted}

\end{frame}

\begin{frame}[fragile]
	\frametitle{Interaction}
	Sensors :
	\begin{itemize}
		\item<1|only@1> Sample external variables. 
\begin{minted}{haskell}
extern :: Typed a => String -> Maybe [a] -> Stream a
\end{minted}
Example : 
\begin{lstlisting}[language=C]
unsigned long long int x;
\end{lstlisting}
\begin{minted}{haskell}
x :: Stream Word64
x = extern "x" (Just [0,0..])

x2 = externW64 "x" Nothing
\end{minted}

		\item<2-4> Sample external variables. 
		\item<2|only@2> Sample external arrays. 
\begin{minted}{haskell}
externArray :: (Typed a, Typed b, Integral a) => 
String -> Stream a -> Int -> Maybe [[a]] -> Stream b
\end{minted}
Example : 
\begin{lstlisting}[language=C]
unsigned long long int tab[1000];
\end{lstlisting}
\begin{minted}{haskell}
-- nat = [0] ++ (nats + 1)
x :: Stream Word64
x = externArray "tab" nats 1000 Nothing

x2 = externArrayW64 "tab" nats 1000 Nothing
\end{minted}
	
		\item<3-4> Sample external arrays. 
		\item<3|only@3> Sample external functions. 

\begin{minted}{haskell}
externFun :: Typed a => 
String -> [FunArg] -> Maybe [a] -> Stream a
\end{minted}
Example :
\begin{lstlisting}[language=C]
double sin(double a); //from math.h
\end{lstlisting}
\begin{minted}{haskell}
x :: Stream Double
x = externDouble "x" Nothing

sinx = externFun "sin" [arg x] Nothing
\end{minted}
		
		\item<4> Sample external functions. 
	\end{itemize}
\end{frame}
  	
\begin{frame}[fragile]
  		\frametitle{Interaction}
  		
	Actuators :
  	\begin{itemize}
		\item Triggers : 
\begin{minted}{haskell}
trigger :: 
  String -> Stream Bool -> [TriggerArg] -> Spec
\end{minted}
		\item Observers :
\begin{minted}{haskell}
observer :: Typed a => String -> Stream a -> Spec
\end{minted}
	\end{itemize}
\end{frame}
  	
  	\subsection{ACSL}
  	\begin{frame}
  		\tableofcontents[currentsubsection,sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
  	\end{frame}
  	
\begin{frame}[fragile]
	\frametitle{ACSL syntax}
	ACSL is a specification language for C programs. Those contracts are written according to the following example :
\begin{lstlisting}[language=C]
/*@ requires true
assigns \nothing
ensures \result >= x && \result >= y;
ensures \result == x || \result == y;
*/
int max (int x, int y) { return (x > y) ? x : y; }
\end{lstlisting}
	
\end{frame}
  	
\begin{frame}[fragile]
	\frametitle{Floyd-Hoare logic}
	A Floyd-Hoare triple is : \\
	$\lbrace P \rbrace~ prog ~\lbrace Q \rbrace$ \\
	\begin{itemize}
		\item $prog$ is a program fragment
		\item $P$ and $Q$ are logical assertions over program variables 
		\item $P$ is the precondition
		\item $Q$ the postcondition
	\end{itemize}
	
	$\lbrace P \rbrace~ prog ~\lbrace Q \rbrace$ holds iff
	\begin{itemize}
		\item $P$ holds before the execution of $prog$
		\item $Q$ holds after the execution of $prog$\footnote{Unless $prog$ does not terminate or encounters an error.}
	\end{itemize}

\end{frame}
	
\begin{frame}[fragile]
	\frametitle{Floyd-Hoare logic}
	Here is an example of a proof tree of a program\footnote{A. Min\'e, \textit{“Semantics and application to program verification : Axiomatic semantics”}, 2015.}:
	\[
	\inferrule* []
	{\inferrule* [] {\inferrule* [] {\inferrule* [] { }
				{\lbrace true \rbrace~ I \leftarrow I - 1 \ ~\lbrace true\rbrace}}
			{\lbrace I \ne 0 \rbrace~ I \leftarrow I - 1 \ ~\lbrace true \rbrace}}
		{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ I \leftarrow I - 1 \ ~\lbrace true \wedge \neg (I \ne 0) \rbrace}
	}
	{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ I \leftarrow I - 1 \ ~\lbrace I = 0 \rbrace}
	\]
\end{frame}

\begin{frame}[fragile]
	\frametitle{Floyd-Hoare logic}
	The Floyd-Hoare logic does not take into account program termination:
	\[
	\inferrule* []
	{\inferrule* [] {\inferrule* [] {\inferrule* [] { }
				{\lbrace true \rbrace~ I \leftarrow I \ ~\lbrace true\rbrace}}
			{\lbrace I \ne 0 \rbrace~ I \leftarrow I \ ~\lbrace true \rbrace}}
		{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ I \leftarrow I \ ~\lbrace true \wedge \neg (I \ne 0) \rbrace}
	}
	{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ I \leftarrow I ~\lbrace I = 0 \rbrace}
	\]
\end{frame}

\begin{frame}[fragile]
	\frametitle{Floyd-Hoare logic}
	Or even safety against runtime errors (we speak about partial correctness):
	\[
	\inferrule* []
	{\inferrule* [] {\inferrule* [] {\inferrule* [] { }
				{\lbrace true \rbrace~ \textbf{fail} \ ~\lbrace true\rbrace}}
			{\lbrace I \ne 0 \rbrace~ \textbf{fail} \ ~\lbrace true \rbrace}}
		{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ \textbf{fail} \ ~\lbrace true \wedge \neg (I \ne 0) \rbrace}
	}
	{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ \textbf{fail} ~\lbrace I = 0 \rbrace}
	\]
	
	More generally, any property is true after fail :
	\[
	\inferrule* [] { }
	{\lbrace P \rbrace~ \textbf{fail} ~\lbrace Q \rbrace}
	\]
\end{frame}

\begin{frame}[fragile]
	\frametitle{Floyd-Hoare logic}
	It is nevertheless possible to prove total correctness by the following proof tree (ranking functions have to be provided):
	\[
	\inferrule* []
	{\lbrace P \rbrace~  prog ~\lbrace Q \rbrace \\ \lbrack P \rbrack~  prog ~\lbrack true \rbrack
	}
	{\lbrack P \rbrack~  prog~ \lbrack Q \rbrack}
	\]
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dijkstra's Weakest Liberal Precondition}
	We define the weakest liberal precondition : $wlp(prog,Q)$  which is defined as the most general condition such that $\lbrace wlp(prog,Q) \rbrace~  prog~ \lbrace Q \rbrace$ holds.\\~\\
	We can automate the computation of the precondition by induction on the syntax. 
	\begin{itemize}
		\item $wlp(skip, P) = P$
		\item $wlp(fail, P) = true$
		\item $wlp(s;t, P) = wlp(s, wlp(t, P))$
		\item $wlp(X \leftarrow e, P) = P[e/X]$
		\item $wlp(\texttt{if}~e~\texttt{then}~s~\texttt{else}~t,P) = (e \Rightarrow wlp(s, P)) \wedge (\neg e \Rightarrow wlp(t, P))$ 
	\end{itemize}
	
\end{frame}

  	\subsection{Copilot toolchain}
  	\begin{frame}
  		\tableofcontents[currentsubsection,sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
  	\end{frame}

\begin{frame}[fragile]
\begin{figure}[ht!]
	\centering
	\footnotesize
\begin{tikzpicture}[->, node distance=2.3cm, auto, shorten >=1pt, bend angle=45,thick]
\tikzstyle{every state}=[rectangle, rounded corners]
	
	
\node[state] (Int) {Interpreter};
\node[state] (Lang) [above right of=Int]
{
	\begin{tabular}[b]{l}
	Copilot Libraries\\ \hline Copilot Language
	\end{tabular}};
\node[state] (Core) [below right of=Lang] {Copilot Core};
\node[state] (PP) [right of=Core] {Pretty Printer};
		
		
\node[state] (Atom) [below left of=Core] {Atom Back-End};
\node[state] (SBV) [below right of=Core] {SBV Back-End};
\node[state] (C99A) [below of=Atom] {C99};
\node[state] (C99S) [below of=SBV] {C99};
		
		
\tikzstyle{every node}=[]
		
		
\path %% (Libs) edge node {0,1,L} (Lang);
%% edge node {1,1,R} (C)
(Lang) edge [bend left, anchor=west, text width=2.5cm] node {Reification and DSL-specific type-checking} (Core)
%% edge node {0,1,L} (C)
(Core) edge node {Translation} (Atom)
edge node {} (SBV)
edge node {} (PP)
edge node [swap] {Evaluation} (Int)
(Int) edge [<->, bend right] node {QuickCheck} (Atom)
(Atom) edge node {Compilation} (C99A)
(SBV) edge node {Compilation} (C99S)
(C99A) edge [<->] node {Model checking} (C99S);
%% edge [bend left] node {Translation} (SBV)
%% (Atom) edge [loop below] node {1,1,R} (D)
%% edge node {0,1,R} (Libs)
%% (SBV) edge [bend left] node {1,0,R} ();
\end{tikzpicture}
\caption{The Copilot toolchain\footnote{L. Pike, N. Wegmann, S. Niller, and A. Goodloe, \textit{Experience report: A do-it-yourself high-assurance compiler}, 2012.}}
	\end{figure}
\end{frame}
  	
  	  	\section{Working on the backend}
  	  	\subsection{Hand-written ACSL}
  	  	\begin{frame}
  	  		\tableofcontents[currentsubsection,sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
  	  	\end{frame}
  	
  	
\begin{frame}[fragile]
\frametitle{Hand written ACSL}

\begin{minted}{haskell}
import Copilot.Language.Reify
import Copilot.Language
import qualified Copilot.Compile.SBV as S
  	
logic :: Stream Bool
logic = [True, False] ++ logic && drop 1 logic
  	
spec :: Spec
spec = do
observer "obs1" logic
  	
main = do
interpret 10 spec
reify spec >>= S.compile S.defaultParams --SBV Backend
  	
\end{minted}
  	
\end{frame}
\begin{frame}[fragile]
	\scriptsize 
\begin{lstlisting}[language=C, keywordstyle=\color{blue}]
/*@
requires ptr_2 < 0x0078;
requires \valid(queue_2 + (0..0x02U-1));
assigns \nothing;
ensures \result == ( queue_2[ptr_2 % 0x02U] 
                && queue_2[(ptr_2 + 0x01U) % 0x02U]);
*/
SBool update_state_2(const SBool *queue_2
                    , const SWord16 ptr_2)
{
  const SWord16 s2 = ptr_2;
  const SWord16 s4 = (0x02U == 0)?s2:(s2%0x02U);
  const SBool   s5 = queue_2[s4];
  const SWord16 s7 = s2 + 0x0001U;
  const SWord16 s8 = (0x02U == 0)?s7:(s7%0x02U);
  const SBool   s9 = queue_2[s8];
  const SBool   s10 = s5 && s9;
  	
  return s10;
}
\end{lstlisting}


\end{frame}
\begin{frame}[fragile]
  	\texttt{frama-c -wp -wp-out . -wp-prover PROVER}
  	
\begin{lstlisting}[]
[wp] Proved goals:   19 / 19
Qed:            18  (4ms-4ms)
cvc4:            1  (150ms-150ms)

[wp] Proved goals:   19 / 19
Qed:            18  (4ms-4ms)
cvc3:            1  (90ms-90ms)
	
[wp] Proved goals:   19 / 19
Qed:            18  (4ms-8ms)
Alt-Ergo:        1  (3.5s-3.5s) (248)

[wp] Proved goals:   19 / 19
Qed:            18  (4ms-4ms)
z3:              1  (20ms-20ms)
\end{lstlisting}
  	
\end{frame}

\begin{frame}[fragile]
	\scriptsize 
	Bitwise version : 
\begin{lstlisting}[language=C]
/*@
requires ptr_2 < 0x0078;
requires \valid(queue_2 + (0..0x02U-1));
assigns \nothing;
ensures \result == ( queue_2[ptr_2 % 0x02U] 
& queue_2[(ptr_2 + 0x01U) % 0x02U]);
*/
SBool update_state_2(const SBool *queue_2
, const SWord16 ptr_2)
{
const SWord16 s2 = ptr_2;
const SWord16 s4 = (0x02U == 0)?s2:(s2%0x02U);
const SBool   s5 = queue_2[s4];
const SWord16 s7 = s2 + 0x0001U;
const SWord16 s8 = (0x02U == 0)?s7:(s7%0x02U);
const SBool   s9 = queue_2[s8];
const SBool   s10 = s5 & s9;

return s10;
}
\end{lstlisting}
	
	
\end{frame}
\begin{frame}[fragile]
	\texttt{frama-c -wp -wp-out . -wp-prover PROVER}
	
\begin{lstlisting}[]
[wp] Proved goals:   15 / 16
Qed:            15  (4ms-4ms)
cvc4:            0  (interrupted: 1)

[wp] Proved goals:   15 / 16
Qed:            15  (4ms-4ms)
cvc3:            0  (unknown: 1)

[wp] Proved goals:   15 / 16
Qed:            15  (4ms-4ms)
Alt-Ergo:        0  (interrupted: 1)

[wp] Proved goals:   15 / 16
Qed:            15  (4ms-4ms)
z3:              0  (interrupted: 1)    
----> Timeout after 30 seconds

\end{lstlisting}
	
\end{frame}

\begin{frame}[fragile]
	\scriptsize 
	Unsafe version : 
\begin{lstlisting}[language=C]
/*@
requires \valid(queue_2 + (0..0x02U-1));
assigns \nothing;
ensures \result == ( queue_2[ptr_2 % 0x02U] 
&& queue_2[(ptr_2 + 0x01U) % 0x02U]);
*/
SBool update_state_2(const SBool *queue_2
, const SWord16 ptr_2)
{
const SWord16 s2 = ptr_2;
const SWord16 s4 = (0x02U == 0)?s2:(s2%0x02U);
const SBool   s5 = queue_2[s4];
const SWord16 s7 = s2 + 0x0001U;
const SWord16 s8 = (0x02U == 0)?s7:(s7%0x02U);
const SBool   s9 = queue_2[s8];
const SBool   s10 = s5 && s9;

return s10;
}
\end{lstlisting}

	
	
\end{frame}
\begin{frame}[fragile]
	\texttt{frama-c -wp -wp-out . -wp-prover PROVER}
	
\begin{lstlisting}[]
[wp] Proved goals:   18 / 19
Qed:            18  (4ms-4ms)
cvc4:            0  (interrupted: 1)

[wp] Proved goals:   18 / 19
Qed:            18  (4ms-4ms)
Alt-Ergo:        0  (interrupted: 1)

[wp] Proved goals:   18 / 19
Qed:            18  (4ms-4ms)
z3:              0  (unknown: 1)   
----> NO TIMEOUT : unsafe
\end{lstlisting}
	
\end{frame}

\subsection{ACSL generation}
\begin{frame}
	\tableofcontents[currentsubsection,sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
\end{frame}


\begin{frame}[fragile]
\frametitle{ACSL generation}
The easiest way to do it is by induction on the syntax, when compiling the expression. Here is how the function ppACSL is constructed :
\begin{itemize}
	\item $\texttt{Const~type~value} \rightarrow show~\texttt{value}$
	\item $\texttt{Drop~type~i~id} \rightarrow queue\_\texttt{id} \lbrack ptr\_\texttt{id} + \texttt{i} ~ mod ~ (length~\texttt{id}) \rbrack$
	\item $\texttt{ExternVar~t~name~b} \rightarrow ext\_\texttt{name}$
	\item $\texttt{Var type name} \rightarrow \texttt{name}$
	\item $\texttt{Op2 op e1 e2} \rightarrow (ppACSL~\texttt{e1})~show~\texttt{op}~(ppACSL~\texttt{e2})$
	\item $\texttt{Label~t~s~e} \rightarrow ppACSL~\texttt{e}$
\end{itemize}
\end{frame}

\begin{frame}[fragile]
yyu
\end{frame}

\begin{frame}[fragile]
	\begin{figure}[ht!]
		\centering
		\footnotesize
		\begin{tikzpicture}[->, node distance=2.3cm, auto, shorten >=1pt, bend angle=45,thick]
		\tikzstyle{every state}=[rectangle, rounded corners]
		
		
		\node[state] (Int) {Interpreter};
		\node[state] (Lang) [above right of=Int]
		{
			\begin{tabular}[b]{l}
			Copilot Libraries\\ \hline Copilot Language
			\end{tabular}};
		\node[state] (Core) [below right of=Lang] {Copilot Core};
		\node[state] (PP) [right of=Core] {Pretty Printer};
		
		
		\node[state] (Atom) [below left of=Core] {Atom Back-End};
		\node[state] (SBV) [below right of=Core] {SBV Back-End};
		\node[state] (C99A) [below of=Atom] {C99};
		\node[state] (C99S) [below of=SBV] {C99};
		
		
		\tikzstyle{every node}=[]
		
		
		\path %% (Libs) edge node {0,1,L} (Lang);
		%% edge node {1,1,R} (C)
		(Lang) edge [bend left, anchor=west, text width=2.5cm] node {Reification and DSL-specific type-checking} (Core)
		%% edge node {0,1,L} (C)
		(Core) edge node {Translation} (Atom)
		edge node {} (SBV)
		edge node {} (PP)
		edge node [swap] {Evaluation} (Int)
		(Int) edge [<->, bend right] node {QuickCheck} (Atom)
		(Atom) edge node {Compilation} (C99A)
		(SBV) edge node {Compilation} (C99S)
		(C99A) edge [<->] node {Model checking} (C99S);
		%% edge [bend left] node {Translation} (SBV)
		%% (Atom) edge [loop below] node {1,1,R} (D)
		%% edge node {0,1,R} (Libs)
		%% (SBV) edge [bend left] node {1,0,R} ();
		\end{tikzpicture}
	\end{figure}
\end{frame}
  	
  	\section{Conclusion}
  	\begin{frame}
  		\frametitle{Questions}
  		\text{Questions ?}
  	\end{frame}
  	
  \end{document}
