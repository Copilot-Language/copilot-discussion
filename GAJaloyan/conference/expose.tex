\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{tabularx}
\usetheme{Frankfurt}
\newcommand\TestAppExists[3]{#2}
\usepackage{minted}
\usepackage{listings}

\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage{tikz-cd}
\usetikzlibrary{positioning}

   
\usepackage{mathpartir}
\usepackage{multicol}
\usepackage{graphicx}



\lstset{ %
	basicstyle=\small\ttfamily,
	breakatwhitespace=true,  
	breaklines=false,        
	commentstyle=\color{green!40!black},   
	extendedchars=true,             
	keepspaces=true,                
	keywordstyle=\color{blue},      
	showspaces=false,               
	showstringspaces=false,         
	showtabs=false,                  
	tabsize=2
}
  
  \setbeamerfont{institute}{size=\fontsize{7pt}{8pt}}
  
  \title{Copilot : Traceability and Verification of a Low Level Automatically Generated C Source Code}
  \author{Georges-Axel Jaloyan}
  \institute{\'Ecole Normale Supérieure, NASA Langley Research center, National Institute of Aerospace}
  \date{August 24, 2015}
  
  \begin{document}
\begin{frame}
  		
  		\titlepage
  		\begin{center}
  			\includegraphics[height=2cm]{images/ENS-logo.jpg} \includegraphics[height=2cm]{images/NASA.png}
  			\includegraphics[height=2cm]{images/NIA-logo.jpg}
  		\end{center}
\end{frame}
  	
  	
  	\section{Preliminaries}
  	\subsection{Copilot language}
\begin{frame}
  		\tableofcontents[currentsubsection,sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
\end{frame}
  	
\begin{frame}
  		\frametitle{Copilot language}
  		Copilot is an \emph{EDSL} (embedded domain specific language), embedded in \emph{Haskell} and used for writing \emph{runtime monitors} for hard real-time, distributed, reactive systems written in C. 
  		\\~\\
  		\text{A Copilot program, can either be : } 
  		\begin{itemize}
  			\item compiled to C using two back-ends : SBV, ATOM
  			\item interpreted
  			\item analyzed using static analysis tools (CBMC, Kind)
  		\end{itemize} 
\end{frame}
  	
\begin{frame}[fragile]
  		\frametitle{Copilot syntax}
  		A program is a list of streams that can be either external  or internal which are defined by mutually recursive stream equations.
  		\\~\\
  		Each stream has a type which can be \texttt{Bool}, \texttt{Int8}, \texttt{Int16}, \texttt{Int32}, \texttt{Int64}, \texttt{Word8}, \texttt{Word16}, \texttt{Word32}, \texttt{Word64}, \texttt{Float}, \texttt{Double}.
  		
\begin{minted}{haskell}
x :: Stream Word16
x = 0
-- x = {0, 0, 0, ...}
y :: Stream Bool
y = x `mod` 2 == 0
-- y = {T, T, ...}
nats :: Stream Word64
nats = [0] ++ (1 + nats)
-- nats = {0,1,2, ..., 2^64-1, 0, 1, ..}  
\end{minted}
\end{frame}
  	
\begin{frame}[fragile]
	\frametitle{Operators}
  		Each operator and constant has been lifted to Streams (working pointwise). \\~\\
  		Two temporal operations working on Streams : 
  		\begin{itemize}
  			\item ++ : which prepends a finite list to a Stream

\begin{minted}{haskell}
(++) :: [a] -> Stream a -> Stream a
\end{minted}
  			\item drop : which drops a finite number of elements at the beginning of a Stream
\begin{minted}{haskell}
drop :: Int -> Stream a -> Stream a  
\end{minted}
  		\end{itemize}
  		
Casts and unsafe casts are also provided :
\begin{minted}{haskell}
cast :: (Typed a, Typed b) => Stream a -> Stream b
unsafeCast :: (Typed a, Typed b) => Stream a -> Stream b
\end{minted}
\end{frame}
  	
\begin{frame}[fragile]
  		\frametitle{Examples}
	Fibonacci sequence :
\begin{minted}{haskell}
fib :: Stream Word64
fib = [1,1] ++ (fib + drop 1 fib) 
-- fib = {1,1,2,3,5,8,13,...,
--       12200160415121876738,
--   /!\ 1293530146158671551,...}
\end{minted}

\end{frame}

\begin{frame}[fragile]
	\frametitle{Interaction}
	Sensors :
	\begin{itemize}
		\item<1|only@1> Sample external variables. 
\begin{minted}{haskell}
extern :: Typed a => String -> Maybe [a] -> Stream a
\end{minted}
Example : 
\begin{lstlisting}[language=C]
unsigned long long int x;
\end{lstlisting}
\begin{minted}{haskell}
x :: Stream Word64
x = extern "x" (Just [0,0..])

x2 = externW64 "x" Nothing
\end{minted}

		\item<2-4> Sample external variables. 
		\item<2|only@2> Sample external arrays. 
\begin{minted}{haskell}
externArray :: (Typed a, Typed b, Integral a) => 
String -> Stream a -> Int -> Maybe [[a]] -> Stream b
\end{minted}
Example : 
\begin{lstlisting}[language=C]
unsigned long long int tab[1000];
\end{lstlisting}
\begin{minted}{haskell}
-- nat = [0] ++ (nats + 1)
x :: Stream Word64
x = externArray "tab" nats 1000 Nothing

x2 = externArrayW64 "tab" nats 1000 Nothing
\end{minted}
	
		\item<3-4> Sample external arrays. 
		\item<3|only@3> Sample external functions. 

\begin{minted}{haskell}
externFun :: Typed a => 
String -> [FunArg] -> Maybe [a] -> Stream a
\end{minted}
Example :
\begin{lstlisting}[language=C]
double sin(double a); //from math.h
\end{lstlisting}
\begin{minted}{haskell}
x :: Stream Double
x = externDouble "x" Nothing

sinx = externFun "sin" [arg x] Nothing
\end{minted}
		
		\item<4> Sample external functions. 
	\end{itemize}
\end{frame}
  	
\begin{frame}[fragile]
  		\frametitle{Interaction}
  		
	Actuators :
  	\begin{itemize}
		\item Triggers : 
\begin{minted}{haskell}
trigger :: 
  String -> Stream Bool -> [TriggerArg] -> Spec
\end{minted}
		\item Observers :
\begin{minted}{haskell}
observer :: Typed a => String -> Stream a -> Spec
\end{minted}
	\end{itemize}
\end{frame}
  	
  	\subsection{ACSL}
  	\begin{frame}
  		\tableofcontents[currentsubsection,sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
  	\end{frame}
  	
\begin{frame}[fragile]
	\frametitle{ACSL syntax}
	ACSL is a specification language for C programs. Those contracts are written according to the following example :
\begin{lstlisting}[language=C]
/*@ requires true
assigns \nothing
ensures \result >= x && \result >= y;
ensures \result == x || \result == y;
*/
int max (int x, int y) { return (x > y) ? x : y; }
\end{lstlisting}
	
\end{frame}
  	
\begin{frame}[fragile]
	\frametitle{Floyd-Hoare logic}
	A Floyd-Hoare triple is : \\
	$\lbrace P \rbrace~ prog ~\lbrace Q \rbrace$ \\
	\begin{itemize}
		\item $prog$ is a program fragment
		\item $P$ and $Q$ are logical assertions over program variables 
		\item $P$ is the precondition
		\item $Q$ the postcondition
	\end{itemize}
	
	$\lbrace P \rbrace~ prog ~\lbrace Q \rbrace$ holds iff
	\begin{itemize}
		\item $P$ holds before the execution of $prog$
		\item $Q$ holds after the execution of $prog$\footnote{Unless $prog$ does not terminate or encounters an error.}
	\end{itemize}

\end{frame}
	
\begin{frame}[fragile]
	\frametitle{Floyd-Hoare logic}
	Here is an example of a proof tree of a program\footnote{A. Min\'e, \textit{“Semantics and application to program verification : Axiomatic semantics”}, 2015.}:
	\[
	\inferrule* []
	{\inferrule* [] {\inferrule* [] {\inferrule* [] { }
				{\lbrace true \rbrace~ I \leftarrow I - 1 \ ~\lbrace true\rbrace}}
			{\lbrace I \ne 0 \rbrace~ I \leftarrow I - 1 \ ~\lbrace true \rbrace}}
		{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ I \leftarrow I - 1 \ ~\lbrace true \wedge \neg (I \ne 0) \rbrace}
	}
	{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ I \leftarrow I - 1 \ ~\lbrace I = 0 \rbrace}
	\]
\end{frame}

\begin{frame}[fragile]
	\frametitle{Floyd-Hoare logic}
	The Floyd-Hoare logic does not take into account program termination:
	\[
	\inferrule* []
	{\inferrule* [] {\inferrule* [] {\inferrule* [] { }
				{\lbrace true \rbrace~ I \leftarrow I \ ~\lbrace true\rbrace}}
			{\lbrace I \ne 0 \rbrace~ I \leftarrow I \ ~\lbrace true \rbrace}}
		{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ I \leftarrow I \ ~\lbrace true \wedge \neg (I \ne 0) \rbrace}
	}
	{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ I \leftarrow I ~\lbrace I = 0 \rbrace}
	\]
\end{frame}

\begin{frame}[fragile]
	\frametitle{Floyd-Hoare logic}
	Or even safety against runtime errors (we speak about partial correctness):
	\[
	\inferrule* []
	{\inferrule* [] {\inferrule* [] {\inferrule* [] { }
				{\lbrace true \rbrace~ \textbf{fail} \ ~\lbrace true\rbrace}}
			{\lbrace I \ne 0 \rbrace~ \textbf{fail} \ ~\lbrace true \rbrace}}
		{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ \textbf{fail} \ ~\lbrace true \wedge \neg (I \ne 0) \rbrace}
	}
	{\lbrace true \rbrace~  \texttt{while} ~ I \ne 0 ~ \texttt{do} ~ \textbf{fail} ~\lbrace I = 0 \rbrace}
	\]
	
	More generally, any property is true after fail :
	\[
	\inferrule* [] { }
	{\lbrace P \rbrace~ \textbf{fail} ~\lbrace Q \rbrace}
	\]
\end{frame}

\begin{frame}[fragile]
	\frametitle{Floyd-Hoare logic}
	It is nevertheless possible to prove total correctness by the following proof tree (ranking functions have to be provided):
	\[
	\inferrule* []
	{\lbrace P \rbrace~  prog ~\lbrace Q \rbrace \\ \lbrack P \rbrack~  prog ~\lbrack true \rbrack
	}
	{\lbrack P \rbrack~  prog~ \lbrack Q \rbrack}
	\]
\end{frame}

  	\subsection{Copilot toolchain}
  	\begin{frame}
  		\tableofcontents[currentsubsection,sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
  	\end{frame}

\begin{frame}[fragile]
\begin{figure}[ht!]
	\centering
	\footnotesize
\begin{tikzpicture}[->, node distance=2.3cm, auto, shorten >=1pt, bend angle=45,thick]
\tikzstyle{every state}=[rectangle, rounded corners]
	
	
\node[state] (Int) {Interpreter};
\node[state] (Lang) [above right of=Int]
{
	\begin{tabular}[b]{l}
	Copilot Libraries\\ \hline Copilot Language
	\end{tabular}};
\node[state] (Core) [below right of=Lang] {Copilot Core};
\node[state] (PP) [right of=Core] {Pretty Printer};
		
		
\node[state] (Atom) [below left of=Core] {Atom Back-End};
\node[state] (SBV) [below right of=Core] {SBV Back-End};
\node[state] (C99A) [below of=Atom] {C99};
\node[state] (C99S) [below of=SBV] {C99};
		
		
\tikzstyle{every node}=[]
		
		
\path %% (Libs) edge node {0,1,L} (Lang);
%% edge node {1,1,R} (C)
(Lang) edge [bend left, anchor=west, text width=2.5cm] node {Reification and DSL-specific type-checking} (Core)
%% edge node {0,1,L} (C)
(Core) edge node {Translation} (Atom)
edge node {} (SBV)
edge node {} (PP)
edge node [swap] {Evaluation} (Int)
(Int) edge [<->, bend right] node {QuickCheck} (Atom)
(Atom) edge node {Compilation} (C99A)
(SBV) edge node {Compilation} (C99S)
(C99A) edge [<->] node {Model checking} (C99S);
%% edge [bend left] node {Translation} (SBV)
%% (Atom) edge [loop below] node {1,1,R} (D)
%% edge node {0,1,R} (Libs)
%% (SBV) edge [bend left] node {1,0,R} ();
\end{tikzpicture}
\caption{The Copilot toolchain\footnote{L. Pike, N. Wegmann, S. Niller, and A. Goodloe, \textit{Experience report: A do-it-yourself high-assurance compiler}, 2012.}}
	\end{figure}
\end{frame}
  	
  	\section{Conclusion}
  	\begin{frame}
  		\frametitle{Questions}
  		\text{Questions ?}
  	\end{frame}
  	
  \end{document}
