\section{Intermediate Language}~\label{sec:il}

\alwyn{Jonathan. This is where we need a lot of work. Since there isn't much in the way of documentation of the code so this section should spell out the syntax of the two formats as well as describe the translation algorithms. You might want to keep the description high level but include two small examples, but I will leave that up to you}

\alwyn{Jonathan. If I remember correctly, the IL format is translated into SMTLIB s-expressions for YICES2 or something very close to that. I'm hoping add a connection to another back end can handle math even a lot of trig stuff, but that's all it does). This would allow us to combine the three provers in really cool ways I think. It will take some experimenting on my part, but will make a cool paper on how we can orchestate the three provers to verify small but rather complex monitors. This desire to do this is one of the reasons I want to get the two translations well documented so me or another student could make add the third prover.} 


Each prover first translates the Copilot specification into an
intermediate representation best suited for model checking. Two
representations are available :

\begin{itemize}
\item
  The \textbf{IL} format : a list
  of quantifier-free equations over integer sequences, implicitly
  universally quantified by a free variable \emph{n}. Each sequence
  roughly corresponds to a stream. This format is the one used in G.
  Hagen's thesis~\cite{HagenPhD}. The \emph{light prover} works with this
  format.
\item
  The \textbf{TransSys} format : a modular representation of a \emph{state transition system} \cite{} The \emph{Kind2 prover} uses thisitio
  format, which is similar to Kind2's native format.
\end{itemize}

\textbf{Cnub} is a simplified representation of a Copilot program where
only the informations useful for SMT-based model checking are kept. For
now, it is not used by the two standard provers but it could be used in
the future as an intermediate step in the translation of a copilot specification to the \textbf{IL} or \textbf{TransSys} format.



%For each of these formats, there is a folder in
%\texttt{src/Copilot/Kind} which contains at least three files

%\begin{itemize}
%\item \texttt{Spec.hs} where the format is defined
%\item \texttt{PrettyPrint.hs} for pretty
%printing (useful for debugging) 
%\item \texttt{Translate.hs} where the
%translation process from \texttt{Core.Spec} is defined
%\end{itemize}

%These three formats share a simplified set of types and operators,
%defined respectively in \texttt{Misc.Type} and \texttt{Misc.Operator}.


\subsection{The \textbf{Cnub} format}

The complexity of the models that are built from Copilot specification is limited by the power and expressiveness of the theories handled by the current SMT solver. For instance, bounded integer arithmetic is often approximated by standard integer arithmetic as overflow problems are ignored and most real functions like trigonometric functions are not handled.

The \textbf{Cnub} format is aimed at abstracting a copilot specification in a format relying on a simple theory including basic integer and real arithmetic and uninterpreted functions. As said before, using it as an intermediate step in the translation process to \textbf{IL} or \textbf{TransSys} would result in a significant simplification of the latter.


In the \textbf{Cnub} format, the stream structure is kept from the copilot core. However, the following differences have to be emphasized :

\begin{itemize}
\item In contrast to the great diversity of numeric types available in Copilot, we restrain ourselves to three basic types which are handled by the \texttt{SMTLib} standard and defined in \texttt{Kind.Misc.Types} : \texttt{Bool}, \texttt{Integer} and \texttt{Real}.


\item \textit{Uninterpreted functions} are used to model operators that are not handled. Uninterpreted functions are abstract symbols with the property that : $$ \left( \forall i . \; x_i = y_i \right) \Longrightarrow f(x_1, \cdots, x_n) = f(y_1, \cdots, y_n). $$ They are provided by most SMT solvers.

\item \textit{Non-deterministic} functions are used to deal with extern values, which corresponds to the copilot constructions \texttt{ExternFun}, \texttt{ExternVar} and \texttt{ExternArray}. They could be seen as uninterpreted functions taking as an additional argument the current time. Indeed, between two clock ticks, they yield the same result if given the same argument. However, they can change at each clock tick.

\end{itemize}


\paragraph{Remark : some ideas to build more faithful models}

Treating machine integers as unbounded integers and complex operators as uninterpreted functions might be an unacceptable approximation in many cases. The first problem could be tackled by adding automatically to the property being verified some bound-checking conditions for all integer variables. This solution has many weaknesses :

\begin{itemize}
\item It treats every program which causes an integer overflow as wrong, although this behaviour could be intended.
\item It generates a great overhead for the proof engine.
\end{itemize}

An intermediate solution could be to let the developper annotate the program so he can specify which bounds have to be checked automatically.


\medskip

The problem of complex operators like trigonometry operators is more difficult to handle. A seemingly good solution would be to give some classical properties of these operators as additional constraints for the SMT solvers. For instance, we could add the following constraint to any specification where the sine function appears : \[ \forall x . \; -1 \leq \sin x \leq 1 \]

Unfortunately, quantifiers are not handled well by the current state of the art SMT solvers.~\footnote{As we will discuss it later, it seems to us it is one of the main limitation of SMT-based techniques which keeps them from scaling well.} An alternative would be to add automatically a specialized version of these constraints for each appropriate variable. For instance, we could add the constraint \[-1 \leq y \leq 1 \] for all variables $y$ such that we have a constraint \[ y = \sin x \] for $x$ any variable. Many refinements of this kind of techniques might be worth studying.





\subsection{The \textbf{IL} format}

In this format, a stream of type $a$ is modeled by a function of type $\mathbb{N} \to a$. Each stream definition is translated into a list of constraints on such functions. For instance, the stream definition :
\begin{code}
fib = [1, 1] ++ (fib + drop 1 fib)
\end{code}
is translated into a function $f : \mathbb{N} \to \mathbb{N}$ with the constraints :
$$
\begin{array}{c}
f(0) = 1 \\
f(1) = 1 \\
\forall n . \; f(n + 2) = f(n + 1) + f(n)
\end{array}
$$

\medskip

Specifications in the \textbf{IL} format can be printed out in the SMTLib format.

\paragraph{The translation process} 

The translation process is straightforward as the reification process~\cite{} has previously transformed the copilot program such that the \texttt{(++)} operator only occurs at the top of a stream definition. Indeed, all stream definitions are written with the pattern
\begin{center}\texttt{ s = [$s_0$,...,$s_p$] ++ e}\end{center}
where \texttt{e} is an expression in which \texttt{(++)} does not occur. In \texttt{Core.Spec}, a stream is defined as :
\begin{code}
data Stream = forall a. Typed a => Stream
  { streamId         :: Id
  , streamBuffer     :: [a]
  , streamExpr       :: Expr a
  , streamExprType   :: Type a }
\end{code}
where the field \texttt{streamBuffer} corresponds to \texttt{[$s_0$,...,$s_p$]} and the field \texttt{streamExpr} to \texttt{e}. Moreover, a simplified definition of the type \texttt{Expr} defined in \texttt{Core.Spec} is :
\begin{code}
data Expr a where
  Const  :: Type a -> a -> Expr a
  Drop   :: Type a -> DropIdx -> Id -> Expr a
  Op2    :: Op2 a b c -> Expr a -> Expr b -> Expr c
\end{code}
Then, the translation algorithm is the following. For each stream equation \begin{center}\texttt{ s = [$s_0$,...,$s_p$] ++ e},\end{center}we introduce a new fresh function $f_s$ and the following constraints :

\begin{itemize}
\item $f_s(i) = s_i$ \quad for $1 \leq i \leq p$
\item $\forall n . \; f_s(n + p) = \texttt{expr}_p \; e$
\end{itemize}
where $\texttt{expr}_p$ is defined in this way on expressions :
\begin{itemize}
\item $\texttt{expr}_p \; (\texttt{Const } v) = v$
\item $\texttt{expr}_p \; (\texttt{Drop } g \; i) = f_g(n + p - i)$
\item $\texttt{expr}_p \; (\texttt{Op2 } \oplus \; x_1 \; x_2) =  {expr}_p \; x_1 \; \oplus \; {expr}_p \; x_2 $
\end{itemize}


\paragraph{A formal specification of the IL format} 


An \textbf{IL} specification is given by :
\begin{itemize}
\item Some identifiers for stream functions and some uninterpreted function symbols
\item A list of constraint between stream functions
\item A list of properties, that is boolean stream functions which should be proved to be constant to \texttt{true}.
Constraints are defined by the following grammar.
\end{itemize}

\bigskip

\begin{tabular}{llclr}
& \textbf{constr} & = & \textbf{expr}$_{Bool}$ & \\
$\forall \tau$ & \textbf{expr}$_{\tau}$ & = & $\left< \textit{const}\,_\tau  \right>$ &\\
& & $\textbar$ & \textit{if} \textbf{expr}$_{Bool}$ \textit{then} \textbf{expr}$_{\tau}$ \textit{else} \textbf{expr}$_{\tau}$ \\

& & $\textbar$ &\textbf{op}$^1_{\alpha, \tau}$ \textbf{expr}$_{\alpha}$ \\
& & $\textbar$ & \textbf{expr}$_{\alpha}$ \textbf{op}$^2_{\alpha, \, \beta, \, \tau}$ \textbf{expr}$_{\beta}$ \\
& & $\textbar$ & $\left< \textit{sid} \,  \right> \, \left(\,\textbf{sindex}\,\right)$ \\
& & $\textbar$ & $\left< \textit{unintid} \,  \right> $ $\left(  \exists \alpha . \, \textbf{expr}_\alpha \right)^{*}$
\\
& \textbf{sindex} & = & $\left< \textit{int} \,  \right> $ & \\
& & $\textbar$ & $ \textit{n} +  \left< \textit{int} \,  \right> $ & \\


& $\cdots$ & & \\
&&& \\

& \textbf{op}$^2_{Int, Int, Int}$ & = & $+ \,\textbar \, - \,\textbar\, *  \,\textbar\, mod  \,\textbar\, div  \,\textbar\, \cdots $ & \\
& \textbf{op}$^2_{Int, Int, Bool}$ & = & $< \,\textbar \, \leq \,\textbar\, \geq \,\textbar\, >  \,\textbar\, =  \,\textbar\, \cdots $ & \\
&&& \\
& $\cdots$ & & \\
&&& \\
\end{tabular}

\medskip

Each expression is parametrized by its type, which belongs to $\{ \texttt{Int}, \texttt{Real},  \texttt{Bool}\}$ and consists in a constant, an \textit{if-then-else} construction or other expressions glued by an operator :

\begin{itemize}
\item The value of a stream at a given time. It consists in an identifier \textit{sid} and an index. The index is either an integer constant or an expression matching the pattern $ \textit{n} +  \left< \textit{int} \,  \right> $, $n$ being an integer variable by which each constraint is implicitly universally quantified.

\item The application of an uninterpreted function, which identifier is given, to a list of arguments.
\end{itemize}
To access a full list of the operators supported by \textit{copilot-kind}, see the module \texttt{Kind.Misc.Operators}.

\subsection{The \textbf{TransSys} format}

As recalled before, a state transition system is a triple $(S,I,T),$
where $S$ is a set of states, $I \subseteq S$ is the set of initial
states and $T \subseteq S \times S $ is a transition relation over $S$.


Here, a state consists in the values of a finite set of variables, which types belong to $\{ \texttt{Int}, \texttt{Real},  \texttt{Bool}\}$. $I$ is encoded by a logical formula whose free variables correspond to the state variables and that holds for a state $q$ if and only if $q$ is an initial state. Similarly, the transition relation is given by a formula $T$ such that $T\left[\, q, \, q' \,\right]$ holds if and only if $q \rightarrow q'$. 


The \textbf{TransSys} format is a modular encoding of such a state transition system. Related variables are grouped into \textit{nodes}, each node providing a distinct namespace and expressing some constraints between its variables. 



\paragraph{Formal definition}

Inside a node, a variable is referenced by a string identifier. Indeed, the corresponding \texttt{Var} type is defined as :
\begin{code}
data Var = Var {varName :: String}
\end{code}
Outside a node, a variable is referenced by a node identifier and an instance of \texttt{Var} :
\begin{code}
data ExtVar = ExtVar {extVarNode :: NodeId, extVarLocalPart :: Var} 
\end{code}
where \texttt{NodeId = String}. Then, the \texttt{Node} type is defined by :
\begin{code}
data Node = Node
  { nodeId            :: NodeId
  , nodeDependencies  :: [NodeId]
  , nodeLocalVars     :: Map Var VarDescr
  , nodeImportedVars  :: Bimap Var ExtVar 
  , nodeConstrs       :: [Expr Bool] }
\end{code} where :
\begin{itemize}
\item \texttt{nodeId} is the identifier of the node
\item \texttt{nodeImportedVars} contains the bijection between the external variables used in the node and their local aliases. Indeed, we can't refer inside a node to an external variable (a variable belonging to another node). Therefore, a mean to bind it to a local name is provided.
\item \texttt{nodeDependencies} is the list of the nodes from which a variable is given a local alias. This information is redundant.
\item \texttt{nodeLocalVars} is a dictionnary which binds each local variable to its descriptor. The type of descriptors \texttt{VarDescr} will be described later.
\item \texttt{nodeConstrs} is a list of constraints on local variables.
\end{itemize}
A variable descriptor consists in a type and a definition :
\begin{code}
data VarDescr = forall t . VarDescr
  { varType :: Type t
  , varDef  :: VarDef t }
\end{code}
Note that in the same way as in \texttt{Copilot.Core}, {\sc gadt}s are used to achieve some additional type safety~\cite{}. The \texttt{VarDef} type is defined as :
\begin{code}
data VarDef t =
    Pre t Var
  | Expr (Expr t)
  | Constrs [Expr Bool]
\end{code}
As we can see, a local variable can be defined
\begin{itemize}
\item as the previous value of another variable (\texttt{Pre} constructor)
\item by an expression involving other variables (\texttt{Expr} constructor)
\item implicitly by a serie of constraints (\texttt{Constrs} constructor)
\end{itemize}
Note that the last constructor can be used to achieve some non-determinism. For instance, a variable whose \texttt{varDef} field is \texttt{Constrs []} is left totally unconstrained.~\footnote{In fact, this is not exact as each constraint which is put in a \texttt{Constrs} constructor could have been put in the \texttt{nodeConstrs} field of the current node instead. However, this is to be avoided for readability and the \texttt{nodeConstrs} field should be left empty as often as possible.
}. The expression type associated with the second constructor is defined as :
\begin{code}
data Expr t where
  Const  :: Type t -> t -> Expr t
  Ite    :: Type t -> Expr Bool -> Expr t -> Expr t -> Expr t
  Op1    :: Type t -> Op1 x t -> Expr x -> Expr t
  Op2    :: Type t -> Op2 x y t -> Expr x -> Expr y -> Expr t
  VarE   :: Type t -> Var -> Expr t
\end{code}
Therefore, an expression is a combination of constants, operators, and local variable names.


Finally, a specification in the \textbf{TransSys} format consists in a list of node and a dictionary binding property names to boolean variables which have to be shown constant equals to \texttt{true}.
\begin{code}
data Spec = Spec
  { specNodes :: [Node]
  , specProps :: Map PropId ExtVar }
\end{code}


\paragraph{Semantics of a transition system}
We give a semantics to \textbf{TransSys} specifications by extracting from them a state transition system in the form of a list of variables and two boolean formulas $I$ and $T$. 

The list of variables is simply a concatenation of the local variables of all nodes. Then, we define the formula $C$ as the concatenation of the fllowing clauses :


\begin{itemize}
\item 
\item 
\end{itemize}









