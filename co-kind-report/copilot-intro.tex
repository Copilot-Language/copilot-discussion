\section{Copilot}~\label{sec:co-intro} 


\paragraph{Copilot's expression language.}
In the following, we briefly and informally introduce Copilot's expression
language.  One design goal for Copilot is to use a familiar syntax and model of
computation; doing so is a first step in reducing specification errors.  The
Copilot language mimics both the syntax and semantics of lazy lists (which we
call \emph{streams}) in Haskell.  One notable exception though is that
operators are automatically promoted point-wise to the list level, much like in
Lustre, a declarative language for embedded programming~\cite{lustre}.  For
example, the Fibonacci sequence modulo $2^{32}$ can be written as follows in Haskell:
%
\begin{code}
fib :: [Word32]
fib = [0,1] ++ zipWith (+) fib (drop 1 fib)
\end{code}
%
In Copilot, the equivalent definition is the following:
\begin{code}
fib :: Stream Word32
fib = [0,1] ++ (fib + drop 1 fib)
\end{code}
%
Copilot overloads or redefines many standard operators from Haskell's Prelude
Library.  Here is a Haskell and equivalent Copilot function that implements a
latch (flip-flop) over streams---the output is the XOR of the input stream and
the latch's previous output.  For example, for the input stream
%
\begin{code}
T, F, F, T, F, F, T, F, F, ...
\end{code}
%
{\tt latch} generates the stream
\begin{code}
F, T, T, T, F, F, F, T, T, T, ...
\end{code}
%
In Haskell, {\tt latch} can be defined
\begin{code}
latch :: [Bool] -> [Bool]
latch x = out x
  where
  out ls   = [False] ++ zipWith xor ls (out ls)
  xor n m  = (n || m) && not (n && m)
\end{code}
%
and then in Copilot ({\tt xor} is a built-in operator for Copilot):
%
\begin{code}
latch :: Stream Bool -> Stream Bool
latch x = out
  where out = [False] ++ x `xor` out
\end{code}
%
The base types of Copilot over which streams are built include Booleans, signed
and unsigned words of 8, 16, 32, and 64 bits, floats, and doubles. Type-safe
casts in which overflow cannot occur are permitted.

\paragraph{Sampling.}
Copilot programs are meant to monitor arbitrary C~programs.  They do
so by
periodically \emph{sampling} symbol values. (Copilot samples variables, arrays,
and the return values of side-effect free functions---sampling arbitrary
structures is future work.)  For a Copilot program compiled to~C, symbols become
in-scope when arbitrary C~code is linked with the code generated by the Copilot
compiler.  Copilot provides the operator {\tt extern} to introduce an external
symbol to sample.  The operator types a string denoting the C~symbol.

Copilot can be interpreted as well as compiled.  When interpreted,
representative values are expected to be supplied by the programmer.  For
example, the following stream samples the C variable {\tt e0} of type {\tt
  uint8\_t} to create each new stream index.  If {\tt e0} takes the values {\tt
  2, 4, 6, 8, ...}  the stream {\tt ext} has the values {\tt 1, 3, 7, 13, ...}.
%
\begin{code}
ext :: Stream Word8
ext = [1] ++ (ext + extern "e0" interp)
  where interp = Just [2,4..]
\end{code}
%
We make the design decision to build interpreter values for external values
into the language.  (If the user wishes not to provide interpreter values,
the constructor {\tt Nothing} can be used.)

Sampling arrays and functions is similar (for space constraints, we omit an
example of function sampling).  For example, the following stream samples an
array with the prototype {\tt uint32\_t arr[3]}:
%
\begin{code}
arr :: Stream Word32
arr = externArray "arr" idx 3 interp
  where idx :: Stream Word8
        idx    = [0] ++ (idx + 1) `mod` 2
        interp = Just (repeat [0,1,2])
\end{code}
% $
The interpreter takes a list of lists to represent possible array values.

Finally, the following stream samples the return value of an external function
with the prototype {\tt int16\_t f(double x, bool y)} by calling the function
with appropriately-typed arguments:
%
\begin{code}
func :: Stream Word16
func = [3] ++ externFun "f" [ arg x, arg y ] interp
  where x :: Stream Double
        x = 3.2
        y :: Stream Double
        y = [5.0] ++ y * 2
        interp = Just (x + y)
\end{code}
%
Note that for functions, the interpreter takes a Copilot program over the input
streams to the function.


\paragraph{Effects.}
Copilot has exactly one mechanism for output called \emph{triggers}.  For
example, consider the following example trigger:
%
\begin{code}
trigger "trig" (fib `mod` 2 == 0)
  [ arg fib, arg (latch fib) ]
\end{code}
A trigger has a guard that is a Boolean-valued Copilot stream, and a list of
arguments, which are Copilot expressions.  A trigger is \emph{fired} exactly
when its guard (stating that the current value from the {\tt fib} stream is
even in this case) is true.  A trigger's implementation is a C~function with a
{\tt void} return type that takes the current values of the trigger arguments as
arguments.  For example, given the definition of {\tt fib} and {\tt latch}
above, the prototype of the C-function implementing the trigger {\tt trig}
defined above is
%
\begin{code}
void trig(uint32_t, bool);
\end{code}
%
The definition of a trigger is implementation-dependent and up to
the programmer to implement.

