\subsection{Monitor Assurance}\label{sec:assurance}
``Who watches the watchmen?''  Nobody.  For this reason, monitors in
ultra-critical systems are the last line of defense and cannot fail.  Here, we
outline our approach to generate high-assurance monitors.  First, as mentioned,
the compiler is statically and strongly typed, and by implementing an eDSL, much
of the infrastructure of a well-tested Haskell implementation is reused.
Copilot contains a custom QuickCheck~\cite{qc}-like test harness that generates
random Copilot programs and tests the interpreted output against the compiler to
ensure correspondence between the two.  We have tested millions of randomly-generated programs
between the compiler and interpreter.

We use the CBMC model checker~\cite{cbmc} to verify C code generated by Copilot
specifications.  CBMC provides an independent check on the compiler.  CBMC can
prove that the C code is memory-safe, including proving there are no arithmetic
underflows or overflows, no division by zero, no not-a-number floating-point
values, no null-pointer dereferences, and no uninitialized local variables.
Some of these potential violations are impossible for the Copilot compiler to
generate (e.g., null-pointer dereferences), provided it is bug-free.  Sometimes
CBMC cannot prove that a C program is memory-safe, since it requires the program
to be loop-free.  The C code generated by Copilot implements a state machine
that generates the next values of the stream equations (see~\cite{copilot} for
details).  CBMC can symbolically unroll the state machine a small fixed number
of steps.  A separate (so far informal) proof must be given that the program has
been unrolled sufficiently to prove memory-safety.  %% Calls to CBMC are integrated
