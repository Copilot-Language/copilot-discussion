\section{Copilot Language} 
\label{sec:language}

Copilot is embedded into the functional programming language Haskell
\cite{PeytonJones02}, and a working knowledge of Haskell is necessary to use
Copilot effectively. Copilot is a pure declarative language; i.e., expressions
are free of side-effects and satisfies referential transparency.  A program
written in Copilot, which from now on will be referred to as a
\emph{specification}, has a cyclic behavior, where each cycle consists of a
fixed series of steps:

\begin{itemize}
\item Sample external variables, arrays, and functions.
\item Update internal variables.
\item Fire external triggers. (In case the specification is violated.)
\end{itemize}

\noindent We refer to a single cycle as an \emph{iteration}.

All transformation of data in Copilot is propagated through streams.
A stream is an infinite, ordered sequence of values which must conform to the same type.
E.g., we have the stream of Fibonacci numbers:

\begin{center}
$s_{fib} = \{0, 1, 1, 2, 3, 5, 8, 13, 21, \dots \}$
\end{center}

\noindent We denote the $n$th value of the stream $s$ as $s(n)$, and the first
value in a sequence $s$ as $s(0)$. For example, for $s_{fib}$ we have that $s_{fib}(0) = 0$,
$s_{fib}(1) = 1$, $s_{fib}(2) = 1$, and so forth.

Constants as well as arithmetic, boolean, and relational operators are
lifted to work pointwise on streams:

\noindent
%\begin{minipage}{0.3\textwidth}
\begin{code}
x :: Stream Int32
x = 5 + 5

y :: Stream Int32
y = x * x

z :: Stream Bool
z = x == 10 && y < 200
\end{code}
%\end{minipage}


\noindent Here the streams {\tt x}, {\tt y}, and {\tt z} are simply
\emph{constant streams}:

\begin{center}
$\mathtt{x} \leadsto \{10, 10, 10, \dots \}$,
$\mathtt{y} \leadsto \{100, 100, 100,  \dots \}$,
$\mathtt{z} \leadsto \{\mbox{T},\; \mbox{T},\; \mbox{T},\; \dots \}$
\end{center}

Two types of \emph{temporal} operators are provided, one for delaying streams and one for
looking into the future of streams:
%
\begin{code}
(++) :: [a] -> Stream a -> Stream a
drop :: Int -> Stream a -> Stream a
\end{code}
%
where the type signature for the function is given in curried
form after the double colon.  Here {\tt xs ++ s} prepends the list
{\tt xs} at the front of the stream {\tt s}.  For example the stream
{\tt w} defined as follows, given our previous definition of {\tt x}:
%
\begin{code}
w = [5,6,7] ++ x
\end{code}
%
evaluates to the sequence
$\mathtt{w} \leadsto \{5, 6, 7, 10, 10, 10, \dots\}$.
The expression {\tt drop k s} skips the first {\tt k} values of the stream {\tt
  s}, returning the remainder of the stream.  
For example we can skip the first two values of {\tt w}:
%
\begin{code}
u = drop 2 w
\end{code}
%
which yields the sequence
$\mathtt{u} \leadsto \{7, 10, 10, 10, \dots\}$.

\subsection{Streams as Lazy-Lists} \label{sec:stream}

A key design choice in Copilot is that streams should mimic \emph{lazy lists}.
In Haskell, the lazy-list of natural numbers can be programmed like this:
%
\begin{code}
nats_ll :: [Int32]
nats_ll = [0] ++ zipWith (+) (repeat 1) nats_ll
\end{code}
%
where $\texttt{zipWith}$ is a higher-order function that takes a
function and two lists as parameters and produces a new list formed by
applying the given function to the elements of the two input lists at
the same position in each list.  As both constants and arithmetic
operators are lifted to work pointwise on streams in Copilot, there is
no need for {\tt zipWith} and {\tt repeat} when specifying the stream
of natural numbers:
%
\begin{code}
nats :: Stream Int32
nats = [0] ++ (1 + nats)
\end{code}
%
In the same manner, the lazy-list of Fibonacci numbers can be specified as follows:
%
\begin{code}
fib_ll :: [Int32]
fib_ll = [1, 1] ++ zipWith (+) fib_ll (drop 1 fib_ll)
\end{code}
%
In Copilot we simply throw away {\tt zipWith}:
\begin{code}
fib :: Stream Int32
fib = [1, 1] ++ (fib + drop 1 fib)
\end{code}

Copilot specifications must be \emph{causal}, informally meaning that
stream values cannot depend on future values.  For example, the following stream
definition is allowed:
%
\begin{code}
f :: Stream Word64
f = [0,1,2] ++ f

g :: Stream Word64
g = drop 2 f
\end{code}
%

But if instead {\tt g} is defined as {\tt g = drop 4 f}, then the definition is
disallowed.  While an analogous stream is definable in a lazy language, we bar
it in Copilot, since it requires future values of {\tt f} to be
generated before producing values for {\tt g}.  This is not possible since
Copilot programs may take inputs in real-time from the environment (see
Section~\ref{sec:interacting}).

\subsection{Functions on Streams} \label{sec:FnOnStreams}

Given that constants and operators work pointwise on streams, we can use Haskell
as a macro-language for defining functions on streams.  The idea of using
Haskell as a macro language is powerful since Haskell is a
general-purpose higher-order functional language.

\begin{example}
We define the function, {\tt even}, which given a stream of
integers returns a boolean stream which is true whenever the input stream
contains an even number, as follows:
%
\begin{code}
even :: Stream Int32 -> Stream Bool
even x = x `mod` 2 == 0
\end{code}
%
Applying {\tt even} on {\tt nats} (defined above) yields the sequence
$\{T, F, T, F, T, F, \dots\}$.
\end{example}

If a function is required to return multiple results, we simply use plain
Haskell tuples:

\begin{example}
We define complex multiplication as follows:
%
\begin{code}
mul_comp
  :: (Stream Double, Stream Double)
  -> (Stream Double, Stream Double)
  -> (Stream Double, Stream Double)
(a, b) `mul_comp` (c, d) = (a * c - b * d, a * d + b * c)
\end{code}
%
Here {\tt a} and {\tt b} represent the real and imaginary part of the left
operand, and {\tt c} and {\tt d} represent the real and imaginary part
of the right operand.
\end{example}

\subsection{Stateful Functions} \label{sec:stateful}

In addition to pure functions, such as {\tt even} and {\tt mul\_comp},
Copilot also facilitates \emph{stateful} functions. A \emph{stateful} function
is a function which has an internal state, e.g. as a latch (as in electronic
circuits) or a low/high-pass filter (as in a DSP).

\begin{figure*}
\begin{minipage}{0.4\linewidth}
\begin{tabular}{c|c||c}
$\mathtt{x}_i$: & $\mathtt{y}_{i-1}$: & $\mathtt{y}_i$:\\
\hline
$F$ & $F$ & $F$ \\
\hline
$F$ & $T$ & $T$ \\
\hline
$T$ & $F$ & $T$ \\
\hline
$T$ & $T$ & $F$
\end{tabular}
\end{minipage}
\hspace{1cm}
\begin{minipage}{0.6\linewidth}
\begin{code}
latch :: Stream Bool -> Stream Bool
latch x = y
  where
  y = if x then not z else z
  z = [False] ++ y
\end{code}
\end{minipage}
\caption{A latch. The specification is provided at the left and the
implementation is provided at the right.}
\label{fig:jk_latch}
\end{figure*}

\begin{example}
We consider a simple latch, as described in \cite{Farhat2004}, with a single
input and a boolean state. Whenever the input is true the internal state is reversed.
The operational behavior and the implementation of the latch is shown in Figure
\ref{fig:jk_latch}.\footnote
{In order
to use conditionals (if-then-else's) in Copilot specifications,
as in Figures~\ref{fig:jk_latch} and~\ref{fig:counter}, the GHC
language extension {\tt RebindableSyntax} must be set on.}
\end{example}

\begin{figure*}
\begin{minipage}{0.4\linewidth}
\begin{tabular}{c|c||c}
$\mathtt{inc}_i$: & $\mathtt{reset}_i$: & $\mathtt{cnt}_i$: \\
\hline
$F$ & $F$ & $\mathtt{cnt}_{i-1}$ \\
\hline
* & $T$ & $0$ \\
\hline
$T$ & $F$ & $\mathtt{cnt}_{i-1} + 1$ \\
\hline
\end{tabular}
\end{minipage}
\hspace{1cm}
\begin{minipage}{0.6\linewidth}
\begin{code}
counter :: Stream Bool -> Stream Bool 
        -> Stream Int32
counter inc reset = cnt
  where 
  cnt = if reset then 0
          else if inc then z + 1
                 else z
  z = [0] ++ cnt
\end{code}
\end{minipage}
\caption{A resettable counter. The specification is provided at the left and the
implementation is provided at the right.
}
\label{fig:counter}
\end{figure*}

\begin{example}
We consider a resettable counter with two inputs, {\tt inc} and {\tt reset}.
The input {\tt inc} increments the counter and the input {\tt reset} resets the
counter. The internal state of the counter, {\tt cnt}, represents the value of the
counter and is initially set to zero. At each cycle, $i$, the value of
$\mathtt{cnt}_i$ is determined as shown in the left table in Figure
\ref{fig:counter}.
\end{example}

%\begin{figure}
%\begin{code}
%fir2pole :: Double -> Double -> Double -> Double
%  -> Double -> Sig Double -> Sig Double
%fir2pole a1 a2 b0 b1 b2 x0 = y0
%  where
%    y0 = - (constant a1)*y1 - (constant a2)*y2
%         + (constant b0)*x0 + (constant b1)*x1 + (constant b2)*x2
%    x2 = [0, 0] ++ x0 ; x1 = drop 1 x2
%    y2 = [0, 0] ++ y0 ; y1 = drop 1 y2
%\end{code}
%\caption{A $2$-pole IIR filter.}
%\label{fig:2_pole_iir_filter}
%\end{figure}

\subsection{Types} \label{sec:types}

Copilot is a typed language, where types are enforced by the Haskell
type system to ensure generated C programs are well-typed.  Copilot is
\emph{strongly typed} (i.e., type-incorrect function application is
not possible) and \emph{statically typed} (i.e., type-checking is done
at compile-time).  The base types are Booleans, unsigned and signed
words of width 8, 16, 32, and 64, floats, and doubles.  All elements
of a stream must belong to the same base type.  These types have
instances for the class {\tt Typed a}, used to constrain Copilot
programs. The constraining type classes are listed to the left of the
$\texttt{=>}$ in a function definition.

We provide a {\tt cast} operator
%
\begin{code}
cast :: (Typed a, Typed b) => Stream a -> Stream b  
\end{code}
%
that casts from one type to another.  The cast operator is only
defined for casts that do not lose information, so an unsigned word
type {\tt a} can only be cast to another unsigned type at least as
large as {\tt a} or to a signed word type strictly larger than {\tt
  a}.  Signed types cannot be cast to unsigned types but can be cast
to signed types at least as large.

\subsection{Interacting With the Target Program}
\label{sec:interacting}

All interaction with the outside world is done by sampling
\emph{external symbols} and by evoking \emph{triggers}.  External
symbols are symbols that are defined outside Copilot and which reflect
the visible state of the target program that we are monitoring.  They
include variables, arrays, and functions (with a non-void return
type).  Analogously, triggers are functions that are defined outside
Copilot and which are evoked when Copilot needs to report that the
target program has violated a specification constraint.

\paragraph{Sampling.}
A Copilot specification is \emph{open} if defined with external
symbols in the sense that values must be provided externally at
runtime.  To simplify writing Copilot specifications that can be
interpreted and tested, constructs for external symbols take an
optional environment for interpretation.

External variables are defined by using the {\tt extern} construct:
%
\begin{code}
extern :: Typed a => String -> Maybe [a] -> Stream a
\end{code}
%
\noindent
where  a value of type $\texttt{Maybe a}$ is either empty
($\texttt{Nothing}$) or a value of type $\texttt{a}$ ($\texttt{Just
  a}$). 
The function \texttt{extern} takes the name of an external variable, a possible Haskell list to
serve as the environment for the interpreter from which the monitor
will draw the values that would otherwise be sampled from the external
program, and generates a stream by sampling the variable at each clock
cycle.  For example,
%
\begin{code}
sumExterns :: Stream Word64
sumExterns = let ex1 = extern "e1" (Just [0..])
                 ex2 = extern "e2" Nothing
             in  ex1 + ex2
\end{code}
%
is a stream that takes two external variables {\tt e1} and {\tt e2} and adds
them.  The first external variable contains the infinite list {\tt [0,1,2,...]}
of values for use when interpreting a Copilot specification containing the
stream.  The other variable contains no environment ({\tt sumExterns} must have
an environment for both of its variables to be interpreted).

Sometimes, type inference cannot infer the type of an external variable.  For
example, in the stream definition
%
\begin{code}
extEven :: Stream Bool
extEven = e0 `mod` 2 == 0
  where e0 = externW8 "x" Nothing 
\end{code}
%
\noindent
the type of {\tt extern "x"} is ambiguous, since it cannot be inferred from a
Boolean stream and we have not given an explicit type signature.  For
convenience, typed {\tt extern} functions are provided, e.g., {\tt externW8} or
{\tt externI64} denoting an external unsigned 8-bit word or signed 64-bit word,
respectively.  In general it is best practice to define external symbols with
top-level definitions, e.g.,
%
\begin{code}
e0 :: Stream Word8
e0 = extern  "e0" (Just [2,4..])
\end{code}

\noindent
so that the symbol name and its environment can be shared between streams.

Besides variables, external arrays and arbitrary functions can be sampled.  The
external array construct has the type
%
\begin{code}
externArray :: (Typed a, Typed b, Integral a) 
            => String -> Stream a -> Int 
            -> Maybe [[a]] -> Stream b  
\end{code}
%
The construct takes (1) the name of an array, (2) a stream that generates indexes for
the array (of integral type), (3) the fixed size of the array, and (4) possibly a list of lists that is the
environment for the external array, representing the sequence of array values.  For example,
%
\begin{code}

extArr :: Stream Word32
extArr = externArray "arr1" arrIdx size 
           (Just $ repeat (permutations [0,1,2]))
  where 
  arrIdx :: Stream Word8
  arrIdx = [0] ++ (arrIdx + 1) `mod` size

  size = 3
\end{code} 
% $
{\tt extArr} is a stream of values drawn from an external array containing
32-bit unsigned words.  The array is indexed by an 8-bit variable.  The index
is ensured to be less than three by using modulo arithmetic.  The environment
provided produces an infinite list of all the permutations of the list {\tt
  [0,1,2]}.\footnote{The function {\tt permutations} comes from the Haskell
    standard library {\tt Data.list}.}


%% %
%% \begin{code}
%% externArray :: (Typed a, Typed b, Integral a) => String -> Stream a -> Stream b
%% externFun :: Typed a => String -> [FunArg] -> Stream a
%% arg :: Typed a => Stream a -> FunArg
%% \end{code}
%% % 
%% The constructor \texttt{externArray} takes two arguments: the name of array and
%% an index into the array.  The index is given by a Copilot stream (of integral
%% type) that is used as an index into the table.

%
\begin{example}
\label{exm:e}
Say we have defined a lookup-table (in C99) of a discretized continuous function that we want to use
within Copilot:
%
\begin{code}
double someTable[42] = { 3.5, 3.7, 4.5, ... };
\end{code}
%
We can use the table in a Copilot specification as follows:
%
\begin{code}
lookupSomeTable :: Stream Word16 -> Stream Double
lookupSomeTable idx = 
  externArray "someTable" idx 42 Nothing
\end{code}
%
Given the following values for \texttt{idx}, $\{1, 0, 2, 2, 1, \dots \}$, the output of 
\texttt{lookupSomeTable idx} would be $$\{3.7, 3.5, 4.5, 4.5, 3.7, \dots \}$$
\end{example}

Finally, the constructor \texttt{externFun} takes (1) a function name, (2) a
list of arguments, and (3) a possible list of values to provide its environment.
%
\begin{code}
externFun :: Typed a => String -> [FunArg] 
          -> Maybe [a] -> Stream a
\end{code}
%
Each argument to an external function is given by a Copilot stream.  For
example,
%
\begin{code}
func :: Stream Word16
func = externFun "f" [arg e0, arg nats] Nothing
  where
  e0 = externW8 "x" Nothing
  nats :: Stream Word8
  nats = [0] ++ nats + 1
\end{code} 
% $
samples a function in C that has the prototype
%
\begin{code}
uint16_t f(uint8_t x, uint8_t nats);
\end{code}
% 

Both external arrays and functions must, like external variables, be defined
in the target program that is monitored. Additionally, external functions must be
without side effects, so that the monitor does not cause undesired side-effects when
sampling functions.  Finally, to ensure Copilot sampling is not
order-dependent, external functions cannot contain streams containing other
external functions or external arrays in their arguments, and external arrays
cannot contain streams containing external functions or external arrays in their
indexes.  They can both take external variables, however.

\paragraph{Triggers.}
Triggers, the only mechanism for Copilot streams to effect the outside world,
are defined by using the {\tt trigger construct}:
%
\begin{code}
trigger :: String -> Stream Bool -> [TriggerArg] -> Spec
\end{code}
%
The first parameter is the name of the external function, the second parameter is the
guard which determines when the trigger should be evoked, and the third parameter
is a list of arguments which is passed to the trigger when evoked.
Triggers can be combined into a specification by using the \emph{do}-notation:
%
\begin{code}
spec :: Spec
spec = do
  trigger "f" (even nats) [arg fib, arg (nats * nats)]
  trigger "g" (fib > 10) []
  let x = externW32 "x" Nothing
  trigger "h" (x < 10) [arg x]
\end{code}
%
The order in which the triggers are defined is irrelevant.

\begin{example}
\label{exm:engine}
We consider an engine controller with the following property: If the temperature
rises more than 2.3 degrees within 0.2 seconds, then the fuel injector should
not be running.  Assuming that the global sample rate is 0.1 seconds, we can
define a monitor that surveys the above property:
%
\begin{code}
propTempRiseShutOff :: Spec
propTempRiseShutOff = 
  trigger "over_temp_rise" 
    (overTempRise && running) []

  where
  max = 500 -- maximum engine temperature

  temps :: Stream Float
  temps = [max, max, max] ++ temp

  temp = extern "temp" Nothing

  overTempRise :: Stream Bool
  overTempRise = drop 2 temps > (2.3 + temps) 
 
  running :: Stream Bool
  running = extern "running" Nothing
\end{code}
%

Here, we assume that the external variable {\tt temp} denotes the temperature of
the engine and the external variable {\tt running} indicates whether the fuel
injector is running.  The external function {\tt over\_temp\_rise} is called
without any arguments if the temperature rises more than 2.3 degrees within 0.2
seconds and the engine is not shut off.  Notice there is a latency of one tick between when the property is violated and when the guard becomes true.
\end{example}

\subsection{Explicit Sharing}
\label{sec:explicit_sharing}

\begin{figure}[ht]
\begin{minipage}{0.5\textwidth}
\begin{code}
s1 = let x = nats + nats
     in x * x
\end{code}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{code}
s2 = local (nats + nats) $
    \ x -> x * x
\end{code} 
% $
\end{minipage}
\caption{Implicit sharing (s1) versus explicit sharing (s2).}
\label{fig:explicit_sharing}
\end{figure}
\noindent Copilot facilitates sharing in expressions by the \emph{local}-construct:
%
\begin{code}
local
  :: (Typed a, Typed b)
  => Stream a
  -> (Stream a -> Stream b)
  -> Stream b
\end{code}
%
The local construct works similar to \emph{let}-bindings in ordinary
Haskell. A stream defined using a local construct typically has the
structure $$\texttt{s} = \texttt{s'}  \  \$ \ \backslash \texttt{x -> e}$$ where
$\texttt{s'}$ is a stream, \$ is Haskell's application operator that
forces function application to associate to the right, and the
\texttt{e} is a lambda expression.  From a semantic point of view, the
streams {\tt s1} and {\tt s2} from Figure \ref{fig:explicit_sharing}
are identical.  As we will see in Section~\ref{subsec:boyer_moore},
however, certain advanced Copilot programs may force the compiler to
build syntax trees that blow up exponentially.  In such cases, using
explicit sharing helps to avoid this problem.


\subsection{Extended Example: The Boyer-Moore Majority-Vote Algorithm}
\label{subsec:boyer_moore}

In this section we demonstrate how to use Haskell as an advanced macro language
on top of Copilot by implementing an algorithm for solving the voting problem
in Copilot.

\begin{figure*}
\begin{code}
majorityPure :: Eq a => [a] -> a
majorityPure []     = error "majorityPure: empty list!"
majorityPure (x:xs) = majorityPure' xs x 1

majorityPure' []     can _   = can
majorityPure' (x:xs) can cnt =
  let
    can' = if cnt == 0 then x else can
    cnt' = if cnt == 0 || x == can then succ cnt else pred cnt
  in
    majorityPure' xs can' cnt'
\end{code}
\caption{The first pass of the majority vote algorithm in Haskell.}
\label{fig:majority_pure}
\end{figure*}

\begin{figure*}
\begin{code}
aMajorityPure :: Eq a => [a] -> a -> Bool
aMajorityPure xs can = aMajorityPure' 0 xs can > length xs `div` 2

aMajorityPure' cnt []     _   = cnt
aMajorityPure' cnt (x:xs) can =
  let
    cnt' = if x == can then cnt+1 else cnt
  in
    aMajorityPure' cnt' xs can
\end{code}
\caption{The second pass of the majority vote algorithm in Haskell.}
\label{fig:amajority_pure}
\end{figure*}

Reliability in mission critical software is often improved by replicating
the same computations on separate hardware and by doing a vote in the end
based on the output of each system. The majority vote problem consists of
determining if in a given list of votes there is a candidate that has more
than half of the votes, and if so, of finding this candidate.

The Boyer-Moore Majority Vote Algorithm \cite{MooreBoyer82,Hesselink2005} solves
the problem in linear time and constant memory. It does so in two passes: The
first pass chooses a candidate; and the second pass asserts that the
found candidate indeed holds a majority.

Without going into details of the algorithm, the first pass can be implemented
in Haskell as shown in Figure \ref{fig:majority_pure}. The second pass, which
simply checks that a candidate has more than half of the votes, is
straightforward to implement and is shown in Figure \ref{fig:amajority_pure}.
E.g. applying {\tt majorityPure} on the string {\tt AAACCBBCCCBCC} yields {\tt
  C}, which {\tt aMajorityPure} can confirm is in fact a majority.

\begin{figure*}[ht]
\begin{code}
majority :: (Eq a, Typed a) => [Stream a] -> Stream a
majority []     = error "majority: empty list!"
majority (x:xs) = majority' xs x 1

majority' []     can _   = can
majority' (x:xs) can cnt =
  local
    (if cnt == 0 then x else can) $
      \ can' ->
        local (if cnt == 0 || x == can then cnt+1 else cnt-1) $
          \ cnt' ->
            majority' xs can' cnt'
\end{code}
\caption{The first pass of the majority vote algorithm in Copilot.}
\label{fig:majority}
\end{figure*}

\begin{figure*}[ht]
\begin{code}
aMajority :: (Eq a, Typed a) => [Stream a] -> Stream a -> Stream Bool
aMajority xs can = aMajority' 0 xs can > (fromIntegral (length xs) `div` 2)

aMajority' cnt []     _   = cnt
aMajority' cnt (x:xs) can =
  local
    (if x == can then cnt+1 else cnt) $
      \ cnt' ->
        aMajority' cnt' xs can
\end{code}
\caption{The second pass of the majority vote algorithm in Copilot.}
\label{fig:amajority}
\end{figure*}
% $

When implementing the majority vote algorithm for Copilot, we can use reuse
almost all of the code from the Haskell implementation. However, as functions
in Copilot are macros that are expanded at compile time, care must
be taken in order to avoid an explosion in the code size. Hence, instead of
using Haskell's built-in \emph{let}-blocks, we use explicit sharing, as
described in Section~\ref{sec:explicit_sharing}. The Copilot implementations
of the first and the second pass are given in Figure \ref{fig:majority} and
Figure \ref{fig:amajority} respectively. Comparing the Haskell implementation
with the Copilot implementation, we see that the code is almost identical,
except for the type signatures and the explicit sharing annotations.



\section{Tools} \label{sec:tools}



\begin{figure*}
\begin{center}
  \begin{tikzpicture}[->, node distance=4cm, auto, shorten >=1pt, bend angle=45,
      thick]
    \tikzstyle{every state}=[rectangle, rounded corners]

    \node[state]         (Int)            {Interpreter};
    \node[state]         (Lang) [above right of=Int]
         {
           \begin{tabular}[b]{l}
           Copilot Libraries\\ \hline Copilot Language
           \end{tabular}};
    \node[state]         (Core) [below right of=Lang]          {Copilot Core};
    \node[state]         (PP) [right of=Core]          {Pretty Printer};

    \node[state]         (Atom) [below left of=Core]     {Atom Back-End};
    \node[state]         (SBV) [below right of=Core]     {SBV Back-End};
    \node[state]         (C99A) [below of=Atom]     {C99};
    \node[state]         (C99S) [below of=SBV]     {C99};

    \tikzstyle{every node}=[]

    \path %% (Libs) edge              node {0,1,L} (Lang);
    %% edge                 node {1,1,R} (C)
    (Lang) edge   [bend left, anchor=west, text width=2.5cm] node {Reification and DSL-specific type-checking} (Core)
    %% edge                 node {0,1,L} (C)
    (Core) edge              node {Translation} (Atom)
    edge              node {} (SBV)
    edge              node {} (PP)
    edge              node [swap] {Evaluation} (Int)
    (Int) edge              [<->, bend right] node {QuickCheck} (Atom)
    (Atom) edge             node {Compilation} (C99A)
    (SBV) edge             node {Compilation} (C99S)
    (C99A) edge              [<->] node  {Model checking} (C99S);

    %% edge [bend left]     node {Translation} (SBV)
    %% (Atom) edge [loop below] node {1,1,R} (D)
    %%     edge                 node {0,1,R} (Libs)
    %% (SBV) edge [bend left]   node {1,0,R} ();
  \end{tikzpicture}
\end{center}
  \caption{The Copilot toolchain.}
  \label{fig:toolchain}
\end{figure*}


As a framework for runtime verification, Copilot comes with a variety
of tools to support the generation of runtime monitor code as well as
to the assist in their assurance. The Copilot toolchain is depicted in
Figure!~\ref{fig:toolchain}.  A Copilot program is transformed into
the Copliot Core language via  process called reification. An
interpreter providing an executable semantics for the Core Language is
provided as an integral part of the toolchain. The interpreter can be
used to prototyping Copilot programs as well as for verification and
validation purposes. Reified programs can be printed using the custom
pretty-printing tool.  Currently, two backends, Atom and SBV,  are
included in the toolchain. Both tools translate Copilot Core language
programs into a  Haskell-hosted EDSL for C code generation.  In
addition, a custom Quickcheck engine and test harness as well as
support of model checkers are sure provided to  aide in verifying the
generated C monitors.  We will demonstrate these tools and their usage
in the remainder of this section.  A more through discussion about the
verification approach can be found in~\cite{PikeWNG2012}.

%%Copilot comes with a variety of tools, including a pretty-printer, an interpreter,
%%two compilers targeting C, and a verifier front-end. In the following section, we will
%%demonstrate some of these tools and their usage.

\subsection{Pretty-Printing} \label{sec:pretty-printing}
Pretty-printing is straightforward.  For some specification {\tt spec},
%
\begin{code}
prettyPrint spec
\end{code}
%
\noindent
returns the specification after static macro expansion.  Pretty-printing can
provide some indication about the complexity of the specification to be
evaluated.  Specifications that are built by recursive Haskell programs (e.g.,
the majority voting example in Section~\ref{subsec:boyer_moore}) can generate
expressions that are large.  Large expressions can take significant
time to interpret or compile.

\subsection{Interpreting Copilot}

The copilot interpreter is invoked as follows (e.g. within GHCI, the GHC compiler's
interpreter for Haskell):
%
\begin{code}
GHCI> interpret 10 propTempRiseShutOff
\end{code}
%
The first argument to the function \emph{interpret} is the number of iterations that we want to evaluate.
The third argument is the specification (of type {\tt Spec}) that we wish to interpret.

The interpreter outputs the values of the arguments passed to the trigger, if
its guard is true, and {\tt --} otherwise.  For example, consider the following
Copilot program:
%
\begin{code}
spec = do 
  trigger "trigger1" (even nats) [arg nats, arg $ odd nats]
  trigger "trigger2" (odd nats) [arg nats]
\end{code}
% $
where {\tt nats} is the stream of natural numbers, and {\tt even} and {\tt odd}
are functions that take a stream and return whether the point-wise values are
even or odd, respectively.  The output of 
%
\begin{code}
interpret 10 spec
\end{code}
%
is as follows:
%
\begin{code}
trigger:   trigger2: 
(0,false)  --        
--         (1)       
(2,false)  --        
--         (3)       
(4,false)  --        
--         (5)       
(6,false)  --        
--         (7)       
(8,false)  --        
--         (9)     
\end{code}
%

Sometimes it is convenient to observe the behavior of a stream without defining
a trigger.  We can do so declaring an \emph{observer}.  For example:
%
\begin{code}
spec :: Spec
spec = observer ``obs'' nats  
\end{code}
%
can be interpreted using
%
\begin{code}
interpret 5 spec  
\end{code}
%
as usual.  Observers can be combined in larger Copilot programs.  For example,
consider the following:
%
\begin{code}
spec :: Spec
spec = do
  let x = externW8 "x" (Just [0..])
  trigger "trigger" true [arg $ x < 3]
  observer "debug_x" x
\end{code}
% $
Interpreting {\tt spec} as follows
%
\begin{code}
interpret 10 spec
\end{code}
%
yields
%
\begin{code}
trigger:  debug_x: 
(true)    0        
(true)    1        
(true)    2        
(false)   3        
(false)   4        
(false)   5        
(false)   6        
(false)   7        
(false)   8        
(false)   9        
\end{code}

\subsection{Compiling Copilot}  \label{sec:compiling}

Compiling the engine controller from Example \ref{exm:engine} is
straightforward.  First, we pick a back-end to compile to.  Currently, two
back-ends are implemented, both of which generate constant-time and
constant-space C code.  One back-end is called \emph{copilot-c99} and targets
the Atom language,\footnote{\url{http://hackage.haskell.org/package/atom}}
originally developed by Tom Hawkins at Eaton Corp. for developing control
systems.  The second back-end is called \emph{copilot-sbv} and targets the SBV
language\footnote{\url{http://hackage.haskell.org/package/sbv}}, originally
developed by Levent Erk\"{o}k.  SBV is primarily used as an interface to SMT
solvers~\cite{smt} and also contains a C-code generator.  Both
languages are open-source.

The two back-ends are installed with Copilot, and they can be imported,
respectively, as

\begin{code}
import Copilot.Compile.C99
\end{code}
\noindent
and
\begin{code}
import Copilot.Compile.SBV
\end{code}

After importing a back-end, the interface for compiling is as
follows:\footnote{Two explanations are in order: (1) {\tt reify} allows sharing in the expressions to be compiled~\cite{DSLExtract}, and {\tt >>=} is a higher-order
  operator that takes the result of reification and ``feeds'' it to the compile
  function.}
%
\begin{code}
reify spec >>= compile defaultParams
\end{code}
%
\noindent
(The compile function takes a parameter to rename the generated C files; {\tt
  defaultParams} is the default, in which there is no renaming.)

The compiler now generates two files:

\begin{itemize}
\item ``copilot.c'' --- 
\item ``copilot.h'' --- 
\end{itemize}

The file named ``copilot.h'' contains prototypes for all external variables, functions, and arrays,
and contains a prototype for the ``step''-functions which evaluates a single iteration.

\begin{code}
/* Generated by Copilot Core v. 0.1 */

#include <stdint.h>
#include <stdbool.h>

/* Triggers (must be defined by user): */

void over_temp_rise();

/* External variables (must be defined by user): */

extern float temp;
extern bool running;

/* Step function: */

void step();
\end{code}

Using the prototypes in ``copilot.h'' we can build a driver as follows:

\begin{code}
/* driver.c */
#include <stdio.h>
#include "copilot.h"

bool running = true;
float temp = 1.1;

void over_temp_rise()
{
  printf("The trigger has been evoked!\n");
}

int main (int argc, char const *argv[])
{
  int i;

  for (i = 0; i < 10; i++)
  {
    printf("iteration: %d\n", i);
    temp = temp * 1.3;
    step();
  }

  return 0;
}
\end{code}

Running ``gcc copilot.c driver.c -o prop'' gives a program ``prop'', which when executed
yields the following output:
%
\begin{code}
iteration: 0
iteration: 1
iteration: 2
iteration: 3
iteration: 4
iteration: 5
iteration: 6
iteration: 7
The trigger has been evoked!
iteration: 8
The trigger has been evoked!
iteration: 9
The trigger has been evoked!
\end{code}
%

\subsection{QuickCheck}
QuickCheck~\cite{qc} is a library originally developed for Haskell such that
given a property, it generates random inputs to test the property.  We provide a
similar tool for checking Copilot specifications.  Currently, the tool is
implemented to check the copilot-c99 back-end against the interpreter.  The tool
generates a random Copilot specification, and for some user-defined number of
iterations, the output of the interpreter is compared against the output of the
compiled C program.  The user can specify weights to influence the probability
at which expressions are generated.  

The copilot QuickCheck tool is installed with Copilot and assuming the binary is
in the path, it is executed as 

\begin{code}
copilot-c99-qc
\end{code}

%%%
%If you have installed Copilot, you can execute the quickCheck tests by executing
%the program {\tt CopilotC99Test}.  The default installation for the executable
%is in {\tt \$HOME/.cabal/bin}. Assuming the executable is in your path, simply
%execute it.  It will direct the user to enter the number of specifications to
%test.  The program will then generate that many random specifications, testing
%the output of the interpreter against the executed C program.  By default, it
%tests the outputs for ten iterations.


\subsection{Verification} \label{sec:verification}
``Who watches the watchmen?''  Nobody.  For this reason, monitors in
ultra-critical systems are the last line of defense and cannot fail.  Here, we
outline our approach to generate high-assurance monitors.  First, as mentioned,
the compiler is statically and strongly typed, and by implementing an eDSL, much
of the infrastructure of a well-tested Haskell implementation is reused.  We
have described our custom QuickCheck engine.  We have tested millions of
randomly-generated programs between the compiler and interpreter with this approach.

Additionally, Copilot includes a tool to generate a driver to prove the
equivalence between the copilot-c99 and copilot-sbv back-ends that each generate
C~code (similar drivers are planned for future back-ends).  To use the driver,
first import the following module:
%
\begin{code}
import qualified Copilot.Tools.CBMC as C
\end{code}
%
\noindent
(We import it using the {\tt qualified} keyword to ensure no name space
collisions.)  Then in GHCI, just like with compilation, we execute
%
\begin{code}
reify spec >>= C.genCBMC C.defaultParams  
\end{code}
%
\noindent
This generates two sets of C sources, one compiled through the copilot-c99
back-end and one through the copilot-sbv back-end.  In addition, a driver (that is, a
{\tt main} function) is generated that executes the code from each back-end.  The
driver has the following form:
%
\begin{code}
int main (int argc, char const *argv[])
{
  int i;

  for (i = 0; i < 10; i++)
  {
    sampleExterns();
    atm_step();
    sbv_step();
    assert(atm_i == sbv_i);
  }

  return 0;
}
\end{code}
%
This driver executes the two generated programs for ten iterations, which is the
default value.  That default can be changed; for example:
%
\begin{code}
reify spec >>= 
  C.genCBMC C.defaultParams {C.numIterations = 20}
\end{code}
%
\noindent
The above executes the generated programs for 20 executions.

The verification depends on an open-source model-checker for C source-code
originally developed at Carnegie Mellon University~\cite{cbmc}.  A license for
the tool is available.~\footnote{\url{http://www.cprover.org/cbmc/LICENSE}.  It
  is the user's responsibility to ensure their use conforms to the license.}
CBMC must be downloaded and installed separately; CBMC is actively maintained
at the time of writing, and is available for Windows, Linux, and Mac OS.

CBMC symbolically executes a program.  With different options, CBMC can be used
to check for arithmetic overflow, buffer overflow/underflow, floating-point NaN
results, and division by zero.  Additionally, CBMC can attempt to verify
arbitrary {\tt assert()} statements placed in the code.  In our case, we wish to
verify that on each iteration, for the same input variables, the two back-ends
have the same state.  

CBMC proves that for all possible inputs, the two programs have the same outputs
for the number of iterations specified.  The time-complexity of CBMC is
exponential with respect to the number of iterations.  Furthermore, CBMC cannot
guarantee equivalence beyond the fixed number of iterations.

After generating the two sets of C source files, CBMC can be executed on the
file containing the driver; for example,
%
\begin{code}
cbmc cbmc_driver.c  
\end{code}
%
