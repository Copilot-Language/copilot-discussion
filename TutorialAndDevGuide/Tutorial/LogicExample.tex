\section{Logic Libraries}~\label{sec:logic}
There are three logic libraries that are useful for monitoring temporal logic
properties: the LTL, PTLTL, and MTL libraries.

\subsection{Bounded Linear Temporal Logic}
The LTL library provides an implementation of a bounded version of Linear
Temporal Logic. Particularly, it provides implementations for the temporal
operators $\bigcirc$ (\verb,next,), $\square$ (\verb,always,),
$\lozenge$ (\verb,eventually,), $\mathbf{U}$ (\verb,until,), and
$\mathbf{R}$ (\verb,release,). Descriptions of the functions in the
bounded LTL library are given in Figure \ref{fig:ltl_desc}.

All LTL properties except those involving only \verb,next,
require a nonnegative bound \verb,n, that gives the number of transitions
after the current period that the LTL property must hold for in order
for the bounded LTL property to be true.
A stream must have sufficient history when being used with
an LTL operator, i.e., any stream to which \verb,next, is applied must
have one value that may be dropped from it and if the nonnegative bound
\verb,n, of an LTL operator is greater than 0, then there must be over
\verb,n, values in the stream that can be dropped.

\begin{figure*}[!htb]
\begin{tabular}{l l}
\verb,next s, & True when the next value of \verb,s, is true\\
\verb,always n s, & True when the current and next \verb,n,
                    values of \verb,s, are all true\\
\verb,eventually n s, & True when at least one of the current or
                        next \verb,n, values of \verb,s, are all true\\
\verb,until n s0 s1, & True when the following hold:
                       \verb,s0, is currently true, \verb,s1,
                       is true at\\
                     & least once in the next \verb,n, steps,
                       and \verb,s0, holds up until the first step\\
                     & that \verb,s1, holds. Requires $\verb,n, > 0$.\\
\verb,release n s0 s1, & True when either the current and next \verb,n,
                         values of \verb,s1, are all true or\\
                       & when the following hold: \verb,s0, is true at
                         least once in the current\\
                       & or next \verb,n, steps and \verb,s1, is
                         true up until and including that step.\\
                       & Requires $\verb,n, > 0$.\
\end{tabular}
\caption{A description of the LTL library functions.}
\label{fig:ltl_desc}
\end{figure*}

Figure \ref{fig:ltl_example} provides an example of the use of LTL library functions
to generate streams for monitors:

\begin{itemize}
\item The first stream \verb,lockedUntil, is used to monitor that
when a door of a vehicle is signalled to be opened, the vehicle
stops within four sampled values and that the doors remain locked
until this stopping occurs.

\item The second stream \verb,switchOnInTime, is used to monitor that
when an event \verb,isEvent, occurs, a switch turns on (\verb,isSwitchOn,
becomes true) within three sampled values.
\end{itemize}

\begin{figure*}[!htb]
\begin{lstlisting}[frame=none]
lockedUntil :: Stream Bool
lockedUntil = openDoorSignal ==> (until 4 isLocked isStopped)
  where
  openDoorSignal :: Stream Bool
  openDoorSignal =
    (replicate 5 False) ++ (extern "open_door_signal" Nothing)
  isLocked :: Stream Bool
  isLocked = (replicate 5 False) ++ (extern "locked" Nothing)
  isStopped :: Stream Bool
  isStopped = (replicate 5 False) ++ (extern "stopped" Nothing)

switchOnInTime :: Stream Bool
switchOnInTime =
  isEvent ==> eventually 3 isSwitchOn
  where
  isSwitchOn :: Stream Bool
  isSwitchOn = (replicate 4 False) ++ (extern "on" Nothing)
  isEvent :: Stream Bool
  isEvent = (replicate 4 False) ++ (extern "event" Nothing)

spec :: Spec
spec = do
  trigger "open_door_lock_problem" (not lockedUntil) []
  trigger "switch_on_in_time_problem" (not switchOnInTime) []
\end{lstlisting}
\caption{An example use of the LTL library.}
\label{fig:ltl_example}
\end{figure*}

\subsection{Past-Time Linear Temporal Logic}
The PTLTL library provides an implementation of Past-Time Linear Temporal Logic,
including implementations for temporal operators
$\overset{\leftarrow}{\bigcirc}$ (\verb,previous,), $\overset{\leftarrow}{\square}$
(\verb,alwaysBeen,), $\overset{\leftarrow}{\lozenge}$ (\verb,eventuallyPrev,),
and $\mathbf{S}$ (\verb,since,), which can be used to monitor
properties that must hold over all the current and past values of the stream.

\begin{figure*}[!htb]
\begin{tabular}{l l}
\verb,previous s, & True when the previous value of \verb,s, is true\\
\verb,alwaysBeen s, & True when the current and previous \verb,n,
                        values of \verb,s, are all true\\
\verb,eventuallyPrev s, & True when at least one of the current or
                            previous \verb,n, values of \verb,s, are all true\\
\verb,since s0 s1, & True when either \verb,s1, never holds or when
                     \verb,s1, first holds at a time \verb,n, and\\
                   & \verb,s0, holds constantly starting from
                     $\verb,n, + 1$
\end{tabular}
\caption{A description of the PTLTL library functions.}
\label{fig:ptltl_desc}
\end{figure*}

The code in Figure \ref{fig:ptltl_example} provides an example of the use of the PTLTL function
\verb,alwaysBeen, to produce a stream that could be used in a monitor:
the stream \verb,countMonotonicallyIncreasing, is true if the values of the
nonnegatively-valued stream \verb,count, have increased monotonically so far.

\begin{figure*}[!htb]
\begin{lstlisting}[frame=none]
countMonotonicallyIncreasing :: Stream Bool
countMonotonicallyIncreasing = alwaysBeen (count >= ([0] ++ count))
  where
  count :: Stream Int32
  count = extern "nonnegative_count" Nothing
\end{lstlisting}
\caption{An example use of a PLTL library function.}
\label{fig:ptltl_example}
\end{figure*}

\subsection{Metric Temporal Logic}
The MTL library is useful for monitoring properties involving
bounded real time.
While the LTL library can be used to monitor properties
associated with real time values if the sampling rate is known, if
samples are not taken precisely at the assumed rate and the amount
of time between samples may vary, then depending on a constant
sampling rate may result in undesired values.

The MTL library provides an implementation of Metric Temporal Logic over a discrete time domain
with implementations of metric temporal operators
$\mathbf{U}_{I}$ (\verb,until,), $\mathbf{S}_{I}$ (\verb,since,), $\mathbf{R}_{I}$ (\verb,release,),
$\mathbf{T}_{I}$ (\verb,trigger,), $\lozenge_{I}$ (\verb,eventually,),
$\square_{I}$ (\verb,always,), $\overset{\leftarrow}{\lozenge}_{I}$ (\verb,eventuallyPrev,), and
$\overset{\leftarrow}{\square}_{I}$ (\verb,alwaysBeen,) along with matching variants
$\mathbf{U}^{\downarrow}_{I}$ (\verb,matchingUntil,),
$\mathbf{S}^{\downarrow}_{I}$ (\verb,matchingSince,),
$\mathbf{R}^{\downarrow}_{I}$ (\verb,matchingRelease,),
and $\mathbf{T}^{\downarrow}_{I}$ (\verb,matchingTrigger,).
A description of the MTL library functions is given in Figure
\ref{fig:mtl_desc}, in which a a stream \verb,s, is ``true at a sampled
time $t$'' iff \verb,s, is true at a sample that aligns with
(is current at the same time as) the
sampled time $t$ in the clock stream \verb,clk,.

\begin{figure*}[!htb]
\begin{tabular}{l l}
\verb,until l u clk dist s0 s1,
  & True when there exists a sampled time $t$ in the\\
  & interval $[\verb,clk + l,, \verb,clk + u,]$ at which \verb,s1,
    is true and\\
  & when \verb,s0, is true for all sampled times in the interval\\
  & $[\verb,clk,, t)$.\\
\verb,since l u clk dist s0 s1,
  & True when there exists a sampled time $t$ in the\\
  & interval $[\verb,clk - u,, \verb,clk - l,]$ at which \verb,s1,
    is true and\\
  & when \verb,s0, is true for all sampled times in the interval\\
  & $(t,\verb,clk,]$.\\
\verb,release l u clk dist s0 s1,
  & True when for all sampled times $t$ in the interval\\
  & $[\verb,clk + l,, \verb,clk + u,]$, \verb,s1, holds or
    there is a sampled\\
  & time in the interval $[\verb,clk,, t)$ when \verb,s0, holds.\\
\verb,trigger l u clk dist s0 s1,
  & True when for all sampled times $t$ in the interval\\
  & $[\verb,clk - u,, \verb,clk - l,]$, \verb,s1, holds or
    there is a sampled\\
  & time in the interval $(t, \verb,clk,]$ when \verb,s0, holds.\\
\verb,eventually l u clk dist s,
  & True when \verb,s, is true at some sampled time in the\\
  & interval $[\verb,clk + l,, \verb,clk + u,]$.\\
\verb,always l u clk dist s,
  & True when \verb,s, is true at all sampled times in the\\
  & interval $[\verb,clk + l,, \verb,clk + u,]$.\\
\verb,eventuallyPrev l u clk dist s, 
  & True when \verb,s, is true at some sampled time in the\\
  & interval $[\verb,clk - u,, \verb,clk - l,]$.\\
\verb,alwaysBeen l u clk dist s,
  & True when \verb,s, is true at all sampled times in the\\
  & interval $[\verb,clk - u,, \verb,clk - l,]$.\\
\verb,matchingUntil l u clk dist s0 s1,
  & True when there exists a sampled time $t$ in the\\
  & interval $[\verb,clk + l,, \verb,clk + u,]$ at which \verb,s1,
    is true and\\
  & when \verb,s0, is true for all sampled times in the interval\\
  & $[\verb,clk,, t]$.\\
\verb,matchingSince l u clk dist s0 s1,
  & True when there exists a sampled time $t$ in the\\
  & interval $[\verb,clk - u,, \verb,clk - l,]$ at which \verb,s1,
    is true and\\
  & when \verb,s0, is true for all sampled times in the interval\\
  & $[t,\verb,clk,]$.\\
\verb,matchingRelease l u clk dist s0 s1,
  & True when for all sampled times $t$ in the interval\\
  & $[\verb,clk + l,, \verb,clk + u,]$, \verb,s1, holds or
    there is a sampled\\
  & time in the interval $[\verb,clk,, t]$ when \verb,s0, holds.\\
\verb,matchingTrigger l u clk dist s0 s1,
  & True when for all sampled times $t$ in the interval\\
  & $[\verb,clk - u,, \verb,clk - l,]$, \verb,s1, holds or
    there is a sampled\\
  & time in the interval $[t, \verb,clk,]$ when \verb,s0, holds.\\
\end{tabular}
\caption{A description of the MTL library functions.}
\label{fig:mtl_desc}
\end{figure*}
Each MTL operator must, in addition to its operand(s),  be provided
with a lower and upper bound for the interval, a stream \verb,clk,
of \verb,Int64, time values sampled at the same rate as the stream(s) being
operated on, and a positive number of time units \verb,dist, giving the
smallest possible difference between adjacent clock samples. Interval bounds
must be nonnegative integers, and intervals include all sampled times
that fall between or equal the provided bounds.

For example, the property $\square_{[10,30]} P$ corresponds to
\verb,always 10 30 clk 2 p,
where \verb,clk, is the stream of clock samples that have a period of
at least 2 and \verb,p, is a \verb,Stream Bool, that is true when
$P$ holds.


As with the LTL library, any streams used with future MTL operators must
have sufficient history.

Figure \ref{fig:mtl_example} contains a specification that monitors a plane's airspeed for a
violation of the property that a plane's speed does not exceed a maximum
airspeed \verb,maxAS, for 60 seconds or longer, where it is known that streams'
values are sampled at a period that is greater than or equal to 1 second.

If this property holds, then at some time within the past 60 seconds,
the airspeed should be less than or equal to the maximum airspeed, i.e.,
the following MTL property should hold:
$$ \overset{\leftarrow}{\lozenge}_{[0,60]}~\verb,airspeed, \leq \verb,maxAS, $$

Whenever this property does not hold, the trigger is evoked in response to
the detected issue.

\begin{figure*}[!htb]
\begin{lstlisting}[frame=none]
maxAirspeedViolation :: Spec
maxAirspeedViolation =
  Copilot.Language.trigger
    "airspeed_violation"
    (not (eventuallyPrev 0 60 clk 1 (airspeed <= maxAS)))
    [arg airspeed, arg clk]
  where
  clk :: Stream Int64
  clk = extern "clk_sec" Nothing
  airspeed :: Stream Double
  airspeed = extern "airspeed" Nothing
  maxAS :: Stream Double
  maxAS = extern "max_airspeed" Nothing
\end{lstlisting}
\caption{An example use of the MTL library.}
\label{fig:mtl_example}
\end{figure*}
