\section{Well Clear Example}~\label{sec:WellClear}

\todo[inline]{Here we will add a detailed description of well clear example}

\begin{itemize}
\item Intro to the problem of monitoring aircraft
\item Overview of concept of well clear citing papers and maybe include some of the PVS models
\item Our monitors with description maybe we show both PVS and Copilot with explanation
\item Properties we have proven
\item code generation 
\item what we had to do to run on ground station. 
\end{itemize}

One application that suits well to the Copilot language is the monitoring of
violations of separation criteria between two planes. We decided to implement
the Well-Clear criterion as an example of practical use.

\todo[inline]{Put here some WellClear stuff}.

Do not forget:

\begin{itemize}
	\item m4
	\item no let binding (everything in functions)
	\item magic labels
	\item following the PVS model (show examples on how close it is). Except for the arrays (HUGE mux stack).
	\item magic makefile
	\item cross compilation on windows
	\item writing the main associated with.
	\item making it work.
\end{itemize}

\subsection{Specification}

{ \footnotesize
\begin{lstlisting}[language=Haskell]

module WCV where

import Prelude ()

import Copilot.Language
import Copilot.Language.Reify
import Copilot.Theorem

import qualified Copilot.Language.Operators.Propositional as P

dthr, tthr, zthr, tcoathr :: Stream Double
dthr    = extern "dthr" Nothing
tthr    = extern "tthr" Nothing
zthr    = extern "zthr" Nothing
tcoathr = extern "tcoathr" Nothing

type Vect2 = (Stream Double, Stream Double)

--------------------------------
-- Relative velocity/position --
--------------------------------

vx, vy, vz :: Stream Double
vx = extern "relative_velocity_x" Nothing
vy = extern "relative_velocity_y" Nothing
vz = extern "relative_velocity_z" Nothing

v :: (Stream Double, Stream Double)
v = (vx, vy)

sx, sy, sz :: Stream Double
sx = extern "relative_position_x" Nothing
sy = extern "relative_position_y" Nothing
sz = extern "relative_position_z" Nothing

s :: (Stream Double, Stream Double)
s = (sx, sy)

------------------
-- Vector stuff --
------------------

(|*|) :: Vect2 -> Vect2 -> Stream Double
(x1, y1) |*| (x2, y2) = (x1 * x2) + (y1 * y2)

sq :: Vect2 -> Stream Double
sq x = x |*| x

norm :: Vect2 -> Stream Double
norm = sqrt . sq

det :: Vect2 -> Vect2 -> Stream Double
det (x1, y1) (x2, y2) = (x1 * y2) - (x2 * y1)

(~=) :: Stream Double -> Stream Double -> Stream Bool
a ~= b = (abs (a - b)) < 0.001

neg :: Vect2 -> Vect2
neg (x, y) = (negate x, negate y)

--------------------
-- Time variables --
--------------------

tau :: Vect2 -> Vect2 -> Stream Double
tau s v = mux (s |*| v < 0) ((-(sq s)) / (s |*| v)) (-1)

tcpa :: Vect2 -> Vect2 -> Stream Double
tcpa s v@(vx, vy) = mux (vx ~= 0 && vy ~= 0) 0 (-(s |*| v)/(sq v))

taumod :: Vect2 -> Vect2 -> Stream Double
taumod s v = mux (s |*| v < 0) ((dthr * dthr - (sq s))/(s |*| v)) (-1)

tep :: Vect2 -> Vect2 -> Stream Double
tep s v = mux ((s |*| v < 0) && ((delta s v dthr) >= 0))
  (theta s v dthr (-1))
  (-1)

delta :: Vect2 -> Vect2 -> Stream Double -> Stream Double
delta s v d = (d*d) * (sq v) - ((det s v)*(det s v))

theta :: Vect2 -> Vect2 -> Stream Double -> Stream Double -> Stream Double
theta s v d e = (-(s |*| v) + e * (sqrt $ delta s v d)) / (sq v)

--------------------------
-- Some tools for times --
--------------------------

tcoa :: Stream Double -> Stream Double -> Stream Double
tcoa sz vz = mux ((sz * vz) < 0) ((-sz) / vz) (-1)

dcpa :: Vect2 -> Vect2 -> Stream Double
dcpa s@(sx, sy) v@(vx, vy) = norm (sx + (tcpa s v) * vx, sy + (tcpa s v) * vy)

--------------------------
-- Well clear violation --
--------------------------

wcv :: (Vect2 -> Vect2 -> Stream Double) ->
       Vect2 -> Stream Double ->
       Vect2 -> Stream Double ->
       Stream Bool
wcv tvar s sz v vz = (horizontalWCV tvar s v) && (verticalWCV sz vz)

verticalWCV :: Stream Double -> Stream Double -> Stream Bool
verticalWCV sz vz =
  ((abs $ sz) <= zthr) ||
  (0 <= (tcoa sz vz) && (tcoa sz vz) <= tcoathr)

horizontalWCV :: (Vect2 -> Vect2 -> Stream Double) -> Vect2 -> Vect2 -> Stream Bool
horizontalWCV tvar s v =
  (norm s <= dthr) ||
  (((dcpa s v) <= dthr) && (0 <= (tvar s v)) && ((tvar s v) <= tthr))

---------------------
-- Local convexity --
---------------------

t1, t2, t3 :: Stream Double
t1 = extern "t1" Nothing
t2 = extern "t2" Nothing
t3 = extern "t3" Nothing

locallyConvex :: (Vect2 -> Vect2 -> Stream Double) -> Stream Bool
locallyConvex tvar = (0 <= t1 && t1 <= t2 && t2 <= t3)
   ==> not ( (wcv tvar (sx + t1*vx, sy + t1*vy) (sz + t1*vz) v vz)
      &&  (not $ wcv tvar (sx + t2*vx, sy + t2*vy) (sz + t2*vz) v vz)
      &&  (wcv tvar (sx + t3*vx, sy + t3*vy) (sz + t3*vz) v vz))

--------------
-- Spec --
--------------

spec :: Spec
spec = do

-------------------------
-- Horizontal symmetry --
-------------------------
  theorem "1a" (forall $ (tau s v)    ~= (tau (neg s) (neg v)))     arith
  theorem "1b" (forall $ (tcpa s v)   ~= (tcpa (neg s) (neg v)))    arith
  theorem "1c" (forall $ (taumod s v) ~= (taumod (neg s) (neg v)))  arith
  theorem "1d" (forall $ (tep s v)    ~= (tep (neg s) (neg v)))     arith

-------------------------
-- Horizontal ordering --
-------------------------
  theorem "2a" (forall $ ((s |*| v) < 0 && (norm s) > dthr && (dcpa s v) <= dthr)
    ==> ((tep s v) <= (taumod s v)))
    arith
  theorem "2b" (forall $ ((s |*| v) < 0 && (norm s) > dthr && (dcpa s v) <= dthr)
    ==> ((taumod s v) <= (tcpa s v)))
    arith
  theorem "2c" (forall $ ((s |*| v) < 0 && (norm s) > dthr && (dcpa s v) <= dthr)
    ==> ((tcpa s v) <= (tau s v)))
    arith

--------------
-- Symmetry --
--------------
  theorem "3a" (forall $
    (wcv tau s sz v vz)    == (wcv tau (neg s) (-sz) (neg v) (-vz)))
    arith
  theorem "3b" (forall $
    (wcv tcpa s sz v vz)   == (wcv tcpa (neg s) (-sz) (neg v) (-vz)))
    arith
  theorem "3c" (forall $
    (wcv taumod s sz v vz) == (wcv taumod (neg s) (-sz) (neg v) (-vz)))
    arith
  theorem "3d" (forall $
    (wcv tep s sz v vz)    == (wcv tep (neg s) (-sz) (neg v) (-vz)))
    arith

---------------
-- Inclusion --
---------------
  theorem "4i"   (forall $ (wcv tau s sz v vz)    ==> (wcv tcpa s sz v vz))
    arith
  theorem "4ii"  (forall $ (wcv tcpa s sz v vz)   ==> (wcv taumod s sz v vz ))
    arith
  theorem "4iii" (forall $ (wcv taumod s sz v vz) ==> (wcv tep s sz v vz))
    arith

---------------------
-- Local convexity --
---------------------
  theorem "5a" (forall $ locallyConvex tcpa)        arith
  theorem "5b" (forall $ locallyConvex taumod)      arith
  theorem "5c" (forall $ locallyConvex tep)         arith
  theorem "6"  (P.not (forall $ locallyConvex tau)) arithSat

---------------------
-- Triggers --
---------------------
  trigger "alert_WCVtau"    (wcv tau s sz v vz)    []
  trigger "alert_WCVtcpa"   (wcv tcpa s sz v vz)   []
  trigger "alert_WCVtaumod" (wcv taumod s sz v vz) []
  trigger "alert_WCVtep"    (wcv tep s sz v vz)    []

----------------------------------------------------------------------------

arith :: Proof Universal
arith    = onlyValidity def { nraNLSat = True, debug = False }

arithSat :: Proof Existential
arithSat = onlySat      def { nraNLSat = True, debug = False }

\end{lstlisting}
}

\subsection{Compiling process}

The Haskell source file is then compiled using the SBV backend. The file is first preprocessed using m4 into an other Haskell file with all constants replaced by their appropriate values. Then, after parsing, we obtain a first AST that is then reified to a core AST (some beta reduction are done), using standard reification techniques in \cite{Copilot06}. Then some AST transformers that keep the semantics are applied, transforming some operands that do not exist in SBV into expressions with only operators with SBV (recip, abs, ...). After this, we first transform the AST into an other one used by SBV, and in the process we generate both ACSL source code and DOT code. This means that the SBV AST contains "decorative" nodes that contain a ACSL or DOT code describing the child AST (TODO modify expression). 

This nodes are then converted into comments into the C sources files that are then checked against the source code generated for the child AST with frama-c wp plugin. This helps us increase the confidence in the compilation process, by checking two different techniques (pretty printing and compilation) each against the other, hence reducing the probability that a similar bug is present both in the pretty printer (which generates the ACSL contracts) and the SBV compiler. Moreover, the same Haskell that has been written at top level has been checked with Metitarski after the m4 expansion. This can be shown by the following Figure~\ref{fig:WCVprocess} :


\begin{figure}[ht!]
	\centering
	\footnotesize
	\begin{tikzpicture}[->, node distance=3cm, auto, shorten >=1pt, bend angle=45,
	thick]
	\tikzstyle{every state}=[rectangle, rounded corners]
	
	\node[state] (Lang) {%
		\begin{tabular}[b]{l}
		Copilot.Language AST
		\end{tabular}};
	
	\node[state] (M5) [left=1.8cm of Lang] {\begin{tabular}[b]{l}
		Preprocessed\\ Haskell
		\end{tabular}};
	\node[state] (M4) [below=1cm of M5] {Haskell};
	\node[state] (RR) [below right of=Lang] {Reified AST};
	\node[state] (Core) [below=0.3cm of RR] {Copilot.Core AST};
	
	
	\node[state] (ACSL) [below right= 2cm of Core] {\begin{tabular}[b]{l}
		ACSL\\ code
		\end{tabular}};
	\node[state] (DOTc) [right of=ACSL] {\begin{tabular}[b]{l}
		DOT\\ code
		\end{tabular}};
	\node[state] (SBV) [below of=Core] {SBV AST};
	\node[state] (C99S) [below of=SBV] {\begin{tabular}[b]{l}
		DOT\\ \hline ACSL\\ \hline C99
		\end{tabular}};
	\node[state] (DOT) [below right of=C99S] {DOT/graphviz};
	\node[state] (SMT) [left=3cm of SBV] {SMTLib code};
	\node[state] (ASM) [below left of= C99S] {Assembly code};
	
	
	\tikzstyle{every node}=[]
	
	
	\path %% (Libs) edge node {0,1,L} (Lang);
	%% edge node {1,1,R} (C)
	(Lang) edge [bend left, anchor=west, text width=2.5cm] node {Reification and DSL-specific type-checking} (RR)
	(RR) edge [anchor=west, text width=2.5cm] node {} (Core)
	%% edge node {0,1,L} (C)
	(M4) edge [text width=2.5cm, anchor = west] node {Preprocessing with m4} (M5)
	(M5) edge [text width=1.5cm] node {Parsing} (Lang)
	(Core) edge [anchor=east] node {Translation} (SBV)
	(ACSL) edge [bend left, anchor=west] node {Integration} (C99S)
	(DOTc) edge [bend left, anchor=east] node {} (C99S)
	(Core) edge [->, anchor=north, text width=3cm] node {ACSL generation} (ACSL)
	(Core) edge [->, anchor=west] node {DOT generation} (DOTc)
	(RR) edge [bend right, ->, anchor=north east,text width=4cm] node {SMTlib generation of high level properties} (SMT)
	(SMT) edge [loop below, ->, anchor=north,text width=4cm] node {Verification with an SMT solver (Z3,...)} (SMT)
	(C99S) edge [->, anchor=east] node {Cross-compilation} (ASM)
	(C99S) edge [loop left, ->, anchor=east] node {Verification with frama-c WP plugin} (C99S)
	(C99S) edge [->, anchor=west] node {Extraction and graph generation} (DOT)
	(SBV) edge [->,anchor=east] node {Compilation} (C99S);
	%% edge [bend left] node {Translation} (SBV)
	%% (Atom) edge [loop below] node {1,1,R} (D)
	%% edge node {0,1,R} (Libs)
	%% (SBV) edge [bend left] node {1,0,R} ();
	\end{tikzpicture}
	\caption{The new Copilot toolchain. The red arrows are the one to implement in the future.}
	\label{fig:WCVprocess}
\end{figure}
