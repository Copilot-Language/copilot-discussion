\subsection{Well Clear Example}~\label{sec:WellClear}


One application that suits well to the Copilot language is the
monitoring of violations of separation criteria between two aircraft.
In civil aviation, the air traffic management  system is designed to  keep
aircraft at a safe distance from each other avoid even the
possibility of a mid-air collision.  In particular,  aircraft are
generally considered safety separated if they maintain 5 mile
horizontal distance from another aircraft and 1000 ft vertical
separation. Technically,  we define  a safe-separation volume around an
aircraft that if violated by an intruder aircraft, the two aircraft
are said to be in conflict. The mathematical definition of this volume
of space around the  moving aircraft  is referred
to as Well Clear. The well-clear boundary defines  the
\emph{well-clear violation volume}, such that "aircraft pairs jointly
occupying this volume are considered to be in a well-clear violation"
[cite DAEDALUS].

Observe the \emph{Well clear violation} section of the code below. The function {\tt wcv} takes in parameters and
checks the horizontal and vertical boundries for violation via the {\tt horizontalWCV} and {\tt verticalWCV} functions respectively. 

\begin{lstlisting}[language = copilot]
--------------------------
-- Well clear violation --
--------------------------

wcv :: (Vect2 -> Vect2 -> Stream Double) ->
       Vect2 -> Stream Double ->
       Vect2 -> Stream Double ->
       Stream Bool
wcv tvar s sz v vz = (horizontalWCV tvar s v) && (verticalWCV sz vz)

verticalWCV :: Stream Double -> Stream Double -> Stream Bool
verticalWCV sz vz =
  ((abs $ sz) <= zthr) ||
  (0 <= (tcoa sz vz) && (tcoa sz vz) <= tcoathr)

horizontalWCV :: (Vect2 -> Vect2 -> Stream Double) -> Vect2 -> Vect2 -> Stream Bool
horizontalWCV tvar s v =
  (norm s <= dthr) ||
  (((dcpa s v) <= dthr) && (0 <= (tvar s v)) && ((tvar s v) <= tthr))
\end{lstlisting}

The main parameters for these functions are {\tt s, v, sz,} and {\tt vz}. {\tt s,v} represents the horizontal position and velocity of the aircraft being monitored, while {\tt sz,vz} represents the vertical position and velocity. We assume that the "other" aircraft is at the origin, so their horizontal and vertical positions are zero. 

To determine if there is a horizontal well clear violation we check whether the position of our own craft ({\tt s}) is less than the distance threshold ({\tt dthr}), which is the closest two aircraft can be within well-clear regulations. If it is, then there is a violation. If not, we then check that the distance at closest point of approach ({\tt dcpa}) corresponding to our position and speed is also less than the distance threshold \emph{and} that the time of that closest point of approach ({\tt tvar}) corresponding to our position and speed is greater than zero and less than the time threshold. If both of these are true, then we have a violation. 

Essentially, we have a violation if either our aircraft is too close to the "other" aircraft (less than {\tt dthr}) or if our aircraft will be too close to the "other aircraft" within a certain amount of time. For example, assume that the distance threshold we choose is 400m. If {\tt s} is less than 400m, we will have a violation. Otherwise, assume our time threshold is 30 seconds. If at the point in the paths of our aircrafts where the two paths are closest is less than 400m apart \emph{and} if both aircrafts hit that point in their paths within 30 seconds of each other, there is a well-clear violation. 

The vertical well clear violation function works much the same way. It first checks whether the vertical position ({\tt sz}) is less than the vertical distance threshold. It then checks that the time at which the two aircraft will have the same vertical given the distance and velocity is less than the time to co-altitude threshold, which is the minimum time at which the two aircraft are allowed to have the same altitude. 

The horizontal and vertical distance and time thresholds are given as external variables, as described in Section~\ref{subsec:interacting}. Similarly, the relative velocity and position for our aircraft with respect to the ``other" aircraft are given as external variables in the \emph{Relative velocity/position} section of the code. The \emph{Vector stuff, Time variables,} and \emph{Some tools for times} sections of the code give us various streams and functions that we reference in the \emph{Well clear violation} section and allow us to do the calculations. 

\begin{itemize}
\item Intro to the problem of monitoring aircraft
\item Overview of concept of well clear citing papers and maybe include some of the PVS models
\item Our monitors with description maybe we show both PVS and Copilot with explanation
\item Properties we have proven
\item code generation 
\item what we had to do to run on ground station. 
\end{itemize}


%Do not forget:

%\begin{itemize}
%	\item m4
%	\item no let binding (everything in functions)
%	\item magic labels
%	\item following the PVS model (show examples on how close it is). Except for the arrays (HUGE mux stack).
%	\item magic makefile
%	\item cross compilation on windows
%	\item writing the main associated with.
%	\item making it work.
%\end{itemize}

\subsubsection{Specification}


\begin{lstlisting}[language=Copilot]

module WCV where

import Prelude ()

import Copilot.Language
import Copilot.Language.Reify
import Copilot.Theorem

import qualified Copilot.Language.Operators.Propositional as P

dthr, tthr, zthr, tcoathr :: Stream Double
dthr    = extern "dthr" Nothing
tthr    = extern "tthr" Nothing
zthr    = extern "zthr" Nothing
tcoathr = extern "tcoathr" Nothing

type Vect2 = (Stream Double, Stream Double)

--------------------------------
-- Relative velocity/position --
--------------------------------

vx, vy, vz :: Stream Double
vx = extern "relative_velocity_x" Nothing
vy = extern "relative_velocity_y" Nothing
vz = extern "relative_velocity_z" Nothing

v :: (Stream Double, Stream Double)
v = (vx, vy)

sx, sy, sz :: Stream Double
sx = extern "relative_position_x" Nothing
sy = extern "relative_position_y" Nothing
sz = extern "relative_position_z" Nothing

s :: (Stream Double, Stream Double)
s = (sx, sy)

------------------
-- Vector stuff --
------------------

(|*|) :: Vect2 -> Vect2 -> Stream Double
(x1, y1) |*| (x2, y2) = (x1 * x2) + (y1 * y2)

sq :: Vect2 -> Stream Double
sq x = x |*| x

norm :: Vect2 -> Stream Double
norm = sqrt . sq

det :: Vect2 -> Vect2 -> Stream Double
det (x1, y1) (x2, y2) = (x1 * y2) - (x2 * y1)

(~=) :: Stream Double -> Stream Double -> Stream Bool
a ~= b = (abs (a - b)) < 0.001

neg :: Vect2 -> Vect2
neg (x, y) = (negate x, negate y)

--------------------
-- Time variables --
--------------------

tau :: Vect2 -> Vect2 -> Stream Double
tau s v = mux (s |*| v < 0) ((-(sq s)) / (s |*| v)) (-1)

tcpa :: Vect2 -> Vect2 -> Stream Double
tcpa s v@(vx, vy) = mux (vx ~= 0 && vy ~= 0) 0 (-(s |*| v)/(sq v))

taumod :: Vect2 -> Vect2 -> Stream Double
taumod s v = mux (s |*| v < 0) ((dthr * dthr - (sq s))/(s |*| v)) (-1)

tep :: Vect2 -> Vect2 -> Stream Double
tep s v = mux ((s |*| v < 0) && ((delta s v dthr) >= 0))
  (theta s v dthr (-1))
  (-1)

delta :: Vect2 -> Vect2 -> Stream Double -> Stream Double
delta s v d = (d*d) * (sq v) - ((det s v)*(det s v))

theta :: Vect2 -> Vect2 -> Stream Double -> Stream Double -> Stream Double
theta s v d e = (-(s |*| v) + e * (sqrt $ delta s v d)) / (sq v)

--------------------------
-- Some tools for times --
--------------------------

tcoa :: Stream Double -> Stream Double -> Stream Double
tcoa sz vz = mux ((sz * vz) < 0) ((-sz) / vz) (-1)

dcpa :: Vect2 -> Vect2 -> Stream Double
dcpa s@(sx, sy) v@(vx, vy) = norm (sx + (tcpa s v) * vx, sy + (tcpa s v) * vy)

--------------------------
-- Well clear violation --
--------------------------

wcv :: (Vect2 -> Vect2 -> Stream Double) ->
       Vect2 -> Stream Double ->
       Vect2 -> Stream Double ->
       Stream Bool
wcv tvar s sz v vz = (horizontalWCV tvar s v) && (verticalWCV sz vz)

verticalWCV :: Stream Double -> Stream Double -> Stream Bool
verticalWCV sz vz =
  ((abs $ sz) <= zthr) ||
  (0 <= (tcoa sz vz) && (tcoa sz vz) <= tcoathr)

horizontalWCV :: (Vect2 -> Vect2 -> Stream Double) -> Vect2 -> Vect2 -> Stream Bool
horizontalWCV tvar s v =
  (norm s <= dthr) ||
  (((dcpa s v) <= dthr) && (0 <= (tvar s v)) && ((tvar s v) <= tthr))

---------------------
-- Local convexity --
---------------------

t1, t2, t3 :: Stream Double
t1 = extern "t1" Nothing
t2 = extern "t2" Nothing
t3 = extern "t3" Nothing

locallyConvex :: (Vect2 -> Vect2 -> Stream Double) -> Stream Bool
locallyConvex tvar = (0 <= t1 && t1 <= t2 && t2 <= t3)
   ==> not ( (wcv tvar (sx + t1*vx, sy + t1*vy) (sz + t1*vz) v vz)
      &&  (not $ wcv tvar (sx + t2*vx, sy + t2*vy) (sz + t2*vz) v vz)
      &&  (wcv tvar (sx + t3*vx, sy + t3*vy) (sz + t3*vz) v vz))

--------------
-- Spec --
--------------

spec :: Spec
spec = do

-------------------------
-- Horizontal symmetry --
-------------------------
  theorem "1a" (forall $ (tau s v)    ~= (tau (neg s) (neg v)))     arith
  theorem "1b" (forall $ (tcpa s v)   ~= (tcpa (neg s) (neg v)))    arith
  theorem "1c" (forall $ (taumod s v) ~= (taumod (neg s) (neg v)))  arith
  theorem "1d" (forall $ (tep s v)    ~= (tep (neg s) (neg v)))     arith

-------------------------
-- Horizontal ordering --
-------------------------
  theorem "2a" (forall $ ((s |*| v) < 0 && (norm s) > dthr && (dcpa s v) <= dthr)
    ==> ((tep s v) <= (taumod s v)))
    arith
  theorem "2b" (forall $ ((s |*| v) < 0 && (norm s) > dthr && (dcpa s v) <= dthr)
    ==> ((taumod s v) <= (tcpa s v)))
    arith
  theorem "2c" (forall $ ((s |*| v) < 0 && (norm s) > dthr && (dcpa s v) <= dthr)
    ==> ((tcpa s v) <= (tau s v)))
    arith

--------------
-- Symmetry --
--------------
  theorem "3a" (forall $
    (wcv tau s sz v vz)    == (wcv tau (neg s) (-sz) (neg v) (-vz)))
    arith
  theorem "3b" (forall $
    (wcv tcpa s sz v vz)   == (wcv tcpa (neg s) (-sz) (neg v) (-vz)))
    arith
  theorem "3c" (forall $
    (wcv taumod s sz v vz) == (wcv taumod (neg s) (-sz) (neg v) (-vz)))
    arith
  theorem "3d" (forall $
    (wcv tep s sz v vz)    == (wcv tep (neg s) (-sz) (neg v) (-vz)))
    arith

---------------
-- Inclusion --
---------------
  theorem "4i"   (forall $ (wcv tau s sz v vz)    ==> (wcv tcpa s sz v vz))
    arith
  theorem "4ii"  (forall $ (wcv tcpa s sz v vz)   ==> (wcv taumod s sz v vz ))
    arith
  theorem "4iii" (forall $ (wcv taumod s sz v vz) ==> (wcv tep s sz v vz))
    arith

---------------------
-- Local convexity --
---------------------
  theorem "5a" (forall $ locallyConvex tcpa)        arith
  theorem "5b" (forall $ locallyConvex taumod)      arith
  theorem "5c" (forall $ locallyConvex tep)         arith
  theorem "6"  (P.not (forall $ locallyConvex tau)) arithSat

---------------------
-- Triggers --
---------------------
  trigger "alert_WCVtau"    (wcv tau s sz v vz)    []
  trigger "alert_WCVtcpa"   (wcv tcpa s sz v vz)   []
  trigger "alert_WCVtaumod" (wcv taumod s sz v vz) []
  trigger "alert_WCVtep"    (wcv tep s sz v vz)    []

----------------------------------------------------------------------------

arith :: Proof Universal
arith    = onlyValidity def { nraNLSat = True, debug = False }

arithSat :: Proof Existential
arithSat = onlySat      def { nraNLSat = True, debug = False }

\end{lstlisting}

