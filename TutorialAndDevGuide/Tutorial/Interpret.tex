\newpage 
\section{Interpreting and Compiling}
\label{interpcompile}
The Copilot RV framework comes with both an interpreter and a
compiler. 
\subsection{Interpreting Copilot}
To use Copilot's interpreter, one must first invoke the GHC Interpreter via
the Cabal sandbox. Invoking the interpreter with the \texttt{cabal
repl} command starts a session that looks like: 

%
\begin{lstlisting}[language = Copilot]
cabal repl
Preprocessing library copilot-2.1.2...
GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help
[1 of 1] Compiling Language.Copilot ( src/Language/Copilot.hs, interpreted )
Ok, modules loaded: Language.Copilot.
*Language.Copilot> 
\end{lstlisting}
%

A copilot file \texttt{file} is loaded as follows:
%
\begin{lstlisting}[language = Copilot]
Language.Copilot> :l file
\end{lstlisting}

Notice that \texttt{file} has to be located
in the directory \emph{Copilot}.

The copilot interpreter is invoked as follows:
%
\begin{lstlisting}[language = Copilot]
Language.Copilot> interpret 10 propTempRiseShutOff
\end{lstlisting}
%
The first argument to the function \emph{interpret} is the number of iterations
that we want to evaluate. The third argument is the specification (of type {\tt
Spec}) that we wish to interpret.

The interpreter outputs the values of the arguments passed to the trigger, if
its guard is true, and {\tt --} otherwise. We will discuss triggers in more detail later, 
but for now, just know that they produce an output only when the guard function
is true. For example, consider the following
Copilot program:
%
\begin{lstlisting}[language = Copilot]
spec = do
  trigger "trigger1" (even nats) [arg nats, arg $ odd nats]
  trigger "trigger2" (odd nats) [arg nats]
\end{lstlisting}
% $
where {\tt nats} is the stream of natural numbers, and {\tt even} and {\tt odd}
are the guard functions that take a stream and return whether the point-wise values are
even or odd, respectively. The lists at the end of the trigger represent the values the 
trigger will output when the guard is true. The output of
%
\begin{lstlisting}[language = Copilot]
interpret 10 spec
\end{lstlisting}
% $
is as follows:
%
\begin{code}
trigger1:   trigger2:
(0,false)  --
--         (1)
(2,false)  --
--         (3)
(4,false)  --
--         (5)
(6,false)  --
--         (7)
(8,false)  --
--         (9)
\end{code}
%

Note that trigger1 outputs both the number and whether that number is odd, while trigger2 only outputs the
number. This output reflects the arguments passed to them. 

Sometimes it is convenient to observe the behavior of a stream without defining
a trigger. We can do so declaring an \emph{observer}. For example:
%
\begin{lstlisting}[language = Copilot]
spec :: Spec
spec = observer "obs" nats
\end{lstlisting}
%
can be interpreted using
%
\begin{lstlisting}[language = Copilot]
interpret 5 spec
\end{lstlisting}
%
as usual and yields
%
\begin{code}
obs:
0
1
2
3
4
\end{code}

\subsection{Compiling Copilot} \label{sec:compiling}

Compiling in Copilot is
straightforward. First, we pick a back-end to compile to. Currently, two
back-ends are implemented, both of which generate constant-time and
constant-space C code. One back-end is called \emph{copilot-c99} and targets
the Atom language,\footnote{\url{http://hackage.haskell.org/package/atom}}
originally developed by Tom Hawkins at Eaton Corp.\ for developing control
systems (in the process of depreciation). The second back-end is called \emph{copilot-sbv} and targets the SBV
language,\footnote{\url{http://hackage.haskell.org/package/sbv}} originally
developed by Levent Erk\"{o}k. SBV is primarily used as an interface to SMT
solvers~\cite{smt} and also contains a C-code generator. Both languages are
open-source.

The two back-ends are installed with Copilot, and they can be imported,
respectively, as

\begin{lstlisting}[language = Copilot]
import Copilot.Compile.C99
\end{lstlisting}
\noindent
and
\begin{lstlisting}[language = Copilot]
import Copilot.Compile.SBV
\end{lstlisting}

After importing a back-end, the interface for compiling is as
follows:
%
\footnote{Two explanations are in order: (1) {\tt reify} allows sharing in the
expressions to be compiled~\cite{DSLExtract}, and {\tt >>=} is a higher-order
operator that takes the result of reification and ``feeds'' it to the compile
function.}
%
\begin{lstlisting}[language = Copilot]
reify spec >>= compile defaultParams
\end{lstlisting}
%
\noindent
(The compile function takes a parameter to rename the generated C files; {\tt
defaultParams} is the default, in which there is no renaming.)

The compiler then generates several files in a separate-subfolder, some of which are called:

\begin{itemize}
\item ``driver.c'' ---
\item ``copilot.h'' ---
\end{itemize}

The file named ``copilot.h'' contains prototypes for all external variables,
functions, and arrays, and contains a prototype for the ``step''-function,
which evaluates a single iteration.




