\section{Interpreting and Compiling}
\label{interpcompile}

\subsection{Interpreting Copilot}
To use Copilot's interpreter, one must first invoke the GHC Interpreter via
the Cabal sandbox. Invoking the interpreter with the \texttt{cabal
repl} command starts a session that looks like: 

%
\begin{lstlisting}[language = Copilot]
cabal repl
Preprocessing library copilot-2.1.2...
GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help
[1 of 1] Compiling Language.Copilot ( src/Language/Copilot.hs, interpreted )
Ok, modules loaded: Language.Copilot.
*Language.Copilot> 
\end{lstlisting}
%

A copilot file \texttt{file} is loaded as follows:
%
\begin{lstlisting}[language = Copilot]
Language.Copilot> :l file
\end{lstlisting}

Notice that \texttt{file} has to be located
in the directory \emph{Copilot}.

The copilot interpreter is invoked as follows:
%
\begin{lstlisting}[language = Copilot]
Language.Copilot> interpret 10 propTempRiseShutOff
\end{lstlisting}
%
The first argument to the function \emph{interpret} is the number of iterations
that we want to evaluate. The third argument is the specification (of type {\tt
Spec}) that we wish to interpret.

The interpreter outputs the values of the arguments passed to the trigger, if
its guard is true, and {\tt --} otherwise. We will discuss triggers in more detail later, 
but for now, just know that they produce an output only when the guard function
is true. For example, consider the following
Copilot program:
%
\begin{lstlisting}[language = Copilot]
spec = do
  trigger "trigger1" (even nats) [arg nats, arg $ odd nats]
  trigger "trigger2" (odd nats) [arg nats]
\end{lstlisting}
% $
where {\tt nats} is the stream of natural numbers, and {\tt even} and {\tt odd}
are the guard functions that take a stream and return whether the point-wise values are
even or odd, respectively. The lists at the end of the trigger represent the values the 
trigger will output when the guard is true. The output of
%
\begin{lstlisting}[language = Copilot]
interpret 10 spec
\end{lstlisting}
% $
is as follows:
%
\begin{code}
trigger1:   trigger2:
(0,false)  --
--         (1)
(2,false)  --
--         (3)
(4,false)  --
--         (5)
(6,false)  --
--         (7)
(8,false)  --
--         (9)
\end{code}
%

Note that trigger1 outputs both the number and whether that number is odd, while trigger2 only outputs the
number. This output reflects the arguments passed to them. 

Sometimes it is convenient to observe the behavior of a stream without defining
a trigger. We can do so declaring an \emph{observer}. For example:
%
\begin{lstlisting}[language = Copilot]
spec :: Spec
spec = observer "obs" nats
\end{lstlisting}
%
can be interpreted using
%
\begin{lstlisting}[language = Copilot]
interpret 5 spec
\end{lstlisting}
%
as usual and yields
%
\begin{code}
obs:
0
1
2
3
4
\end{code}

\subsection{Compiling Copilot} \label{sec:compiling}

Compiling in Copilot is
straightforward. First, we pick a back-end to compile to. Currently, two
back-ends are implemented, both of which generate constant-time and
constant-space C code. One back-end is called \emph{copilot-c99} and targets
the Atom language,\footnote{\url{http://hackage.haskell.org/package/atom}}
originally developed by Tom Hawkins at Eaton Corp.\ for developing control
systems (in the process of depreciation). The second back-end is called \emph{copilot-sbv} and targets the SBV
language,\footnote{\url{http://hackage.haskell.org/package/sbv}} originally
developed by Levent Erk\"{o}k. SBV is primarily used as an interface to SMT
solvers~\cite{smt} and also contains a C-code generator. Both languages are
open-source.

The two back-ends are installed with Copilot, and they can be imported,
respectively, as

\begin{lstlisting}[language = Copilot]
import Copilot.Compile.C99
\end{lstlisting}
\noindent
and
\begin{lstlisting}[language = Copilot]
import Copilot.Compile.SBV
\end{lstlisting}

After importing a back-end, the interface for compiling is as
follows:
%
\footnote{Two explanations are in order: (1) {\tt reify} allows sharing in the
expressions to be compiled~\cite{DSLExtract}, and {\tt >>=} is a higher-order
operator that takes the result of reification and ``feeds'' it to the compile
function.}
%
\begin{lstlisting}[language = Copilot]
reify spec >>= compile defaultParams
\end{lstlisting}
%
\noindent
(The compile function takes a parameter to rename the generated C files; {\tt
defaultParams} is the default, in which there is no renaming.)

The compiler then generates several files in a separate-subfolder, some of which are called:

\begin{itemize}
\item ``driver.c'' ---
\item ``copilot.h'' ---
\end{itemize}

The file named ``copilot.h'' contains prototypes for all external variables,
functions, and arrays, and contains a prototype for the ``step''-function,
which evaluates a single iteration.

\subsection{Compiling process}

\textbf{From section 8, unedited}

The Haskell source file is then compiled using the SBV backend. The file is first preprocessed using m4 into an other Haskell file with all constants replaced by their appropriate values. Then, after parsing, we obtain a first AST that is then reified to a core AST (some beta reduction are done), using standard reification techniques in \cite{Copilot06}. Then some AST transformers that keep the semantics are applied, transforming some operands that do not exist in SBV into expressions with only operators with SBV (recip, abs, ...). After this, we first transform the AST into an other one used by SBV, and in the process we generate both ACSL source code and DOT code. This means that the SBV AST contains "decorative" nodes that contain a ACSL or DOT code describing the child AST (TODO modify expression). 

This nodes are then converted into comments into the C sources files that are then checked against the source code generated for the child AST with frama-c wp plugin. This helps us increase the confidence in the compilation process, by checking two different techniques (pretty printing and compilation) each against the other, hence reducing the probability that a similar bug is present both in the pretty printer (which generates the ACSL contracts) and the SBV compiler. Moreover, the same Haskell that has been written at top level has been checked with Metitarski after the m4 expansion. This can be shown by the following Figure~\ref{fig:WCVprocess} :


\begin{figure}[hbt!]
	\centering
	\footnotesize
	\begin{tikzpicture}[->, node distance=3cm, auto, shorten >=1pt, bend angle=45,
	thick]
	\tikzstyle{every state}=[rectangle, rounded corners]
	
	\node[state] (Lang) {%
		\begin{tabular}[b]{l}
		Copilot.Language AST
		\end{tabular}};
	
	\node[state] (M5) [left=1.8cm of Lang] {\begin{tabular}[b]{l}
		Preprocessed\\ Haskell
		\end{tabular}};
	\node[state] (M4) [below=1cm of M5] {Haskell};
	\node[state] (RR) [below right of=Lang] {Reified AST};
	\node[state] (Core) [below=0.3cm of RR] {Copilot.Core AST};
	
	
	\node[state] (ACSL) [below right= 2cm of Core] {\begin{tabular}[b]{l}
		ACSL\\ code
		\end{tabular}};
	\node[state] (DOTc) [right of=ACSL] {\begin{tabular}[b]{l}
		DOT\\ code
		\end{tabular}};
	\node[state] (SBV) [below of=Core] {SBV AST};
	\node[state] (C99S) [below of=SBV] {\begin{tabular}[b]{l}
		DOT\\ \hline ACSL\\ \hline C99
		\end{tabular}};
	\node[state] (DOT) [below right of=C99S] {DOT/graphviz};
	\node[state] (SMT) [left=3cm of SBV] {SMTLib code};
	\node[state] (ASM) [below left of= C99S] {Assembly code};
	
	
	\tikzstyle{every node}=[]
	
	
	\path %% (Libs) edge node {0,1,L} (Lang);
	%% edge node {1,1,R} (C)
	(Lang) edge [bend left, anchor=west, text width=2.5cm] node {Reification and DSL-specific type-checking} (RR)
	(RR) edge [anchor=west, text width=2.5cm] node {} (Core)
	%% edge node {0,1,L} (C)
	(M4) edge [text width=2.5cm, anchor = west] node {Preprocessing with m4} (M5)
	(M5) edge [text width=1.5cm] node {Parsing} (Lang)
	(Core) edge [anchor=east] node {Translation} (SBV)
	(ACSL) edge [bend left, anchor=west] node {Integration} (C99S)
	(DOTc) edge [bend left, anchor=east] node {} (C99S)
	(Core) edge [->, anchor=north, text width=3cm] node {ACSL generation} (ACSL)
	(Core) edge [->, anchor=west] node {DOT generation} (DOTc)
	(RR) edge [bend right, ->, anchor=north east,text width=4cm] node {SMTlib generation of high level properties} (SMT)
	(SMT) edge [loop below, ->, anchor=north,text width=4cm] node {Verification with an SMT solver (Z3,...)} (SMT)
	(C99S) edge [->, anchor=east] node {Cross-compilation} (ASM)
	(C99S) edge [loop left, ->, anchor=east] node {Verification with frama-c WP plugin} (C99S)
	(C99S) edge [->, anchor=west] node {Extraction and graph generation} (DOT)
	(SBV) edge [->,anchor=east] node {Compilation} (C99S);
	%% edge [bend left] node {Translation} (SBV)
	%% (Atom) edge [loop below] node {1,1,R} (D)
	%% edge node {0,1,R} (Libs)
	%% (SBV) edge [bend left] node {1,0,R} ();
	\end{tikzpicture}
	\caption{The whole process of WCV compilation.}
	\label{fig:WCVprocess}
\end{figure}

\begin{figure}[hbt!]
	\centering
	\footnotesize
	\begin{tikzpicture}[->, node distance=2.3cm, auto, shorten >=1pt, bend angle=45,thick]
	\tikzstyle{every state}=[rectangle, rounded corners]
	
	\node[state] (Plane) {Planes};
	\node[state] (GUI) [right of=Plane] {GUI};
	\node[state] (Mon) [right=2cm of GUI] {monitor.c};
	\node[state] (dr) [right of=Mon] {driver.c};
	\node[state] (ex) [above right of=Mon] {external};
	
	
	\node[state] (AL) [below of=GUI] {ALERT};
	\node[state] (Co) [below of=Mon] {Converter};
	
	
	\tikzstyle{every node}=[]
	
	
	\path
	(Plane) edge node {UDP} (GUI)
	(GUI) edge [bend right] node {stdin} (Mon)
	(Mon) edge [bend right] node {stdout} (GUI)
	(Mon) edge [bend left, anchor=west] node {lat-long} (Co)
	(Co) edge [bend left, anchor=west] node[left] {x,y,z} (Mon)
	(Mon) edge [anchor=west] node {assign} (ex)
	(Mon) edge [anchor=south] node {call} (dr)
	(ex) edge [anchor=west] node {feed} (dr)
	(GUI) edge node {} (AL);
	\end{tikzpicture}
	\caption{The ground station monitor structure}.
	\label{fig:gss}
\end{figure}

Then we made it comply to real application with the following scheme in Figure~\ref{fig:gss} :
\begin{itemize}
	\item The planes send raw data via UDP network system in the form of lat-long-alt, tgs, hdg, vspeed.
	\item All these data are collected by a GUI, that has the role of sending these data to the monitor, and getting back the monitor's data to show if any alert has been raised (the role of the GUI is to make the sound, or blink LEDs everywhere in the ALERT module).
	\item The monitor.c is a c file that can receive 3 different instructions :
	\subitem A new plane entered in the control area (ICAO24 given)
	\subitem A plane is leaving the area (with ICAO24 given)
	\subitem A plane is updating its coordinates (ICAO24 + lat-long-alt-hdg-tgs-vertical speed format). In this case, the plane is converting the coordinates into classical x,y,z with the Converter (TODO : put the real coordinates system somewhere). And then for all planes, it checks if this plane is in a WCV conflit with it (using the driver.c generated by Copilot). If yes, it raises an alert on stdout for every plane that is in conflict. 
\end{itemize}

